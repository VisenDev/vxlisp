(package vx/core
 :libs (lib javafuture)
       (lib javafunction)
       (lib javacollectors)
 :doc "Core VxLisp Library. Unfortunately large because of interdependencies.")

(type any
 :convert [int    string string<-int
           string int    int<-string]
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_any vx_type_from_any(vx_core::Type_any value) const;")
 :doc "Any Value for Variant Type")

(type any-async<-func
 :extends    :func
 :allowfuncs [any<-func any<-func-async]
 :doc        "A sync or async function that returns one value.")

(type any<-anylist
 :extends    :list
 :allowfuncs [any<-any]
 :doc        "List of Any")

(type anylist
 :extends    :list
 :allowtypes [any])

(type anytype
 :extends :type
 :doc     "Any Type that allows any Type as a Value")

(type arg
 :extends    :struct
 :properties [name    : string
              argtype : type
              fn-any  : any<-func]
 :doc        "A function argument")

(type arglist
 :extends    :list
 :allowtypes [arg]
 :doc        "A list of arg")

(type argmap
 :extends    :map
 :allowtypes [arg]
 :doc        "A map of arg")

(type boolean
 :default     false
 :allowvalues [true false]
 :create
  (native
   :cpp
    "// :header
     bool vx_p_boolean = false;
     bool vx_boolean() const;"
   :java
    "protected boolean vxboolean = false;

     @Override
     public boolean vx_boolean() {return vxboolean;}

     @Override
     public Type_boolean vx_new_from_boolean(final boolean isval) {
       Type_boolean output = Core.c_false;
       if (isval) {
         output = Core.c_true;
       }
       return output;
     }")
 :test (test-true true)
       (test-false false)
       (test-true (boolean true))
       (test-false (boolean false))
 :doc "Standard Boolean Type")

(type booleanlist
 :extends    :list
 :allowtypes [boolean])

(type collection
 :allowtypes [list map])

(type compilelanguages
 :default     :unknown
 :allowvalues [:unknown :c :c++ :clj :cljs :go :java :js :rust])

(type connect
 :doc "General connect trait")

(type connectlist
 :extends    :list
 :allowtypes [connect]
 :doc        "List of connect")

(type connectmap
 :extends    :map
 :allowtypes [connect]
 :doc        "Map of connect")

(type const
 :extends :const
 :doc     "Original Constant Class.")

(type constdef
 :extends    :struct
 :properties [pkgname : string
              name    : string
              type    : any]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_constdef vx_constdef_new(
       std::string pkgname,
       std::string name,
       vx_core::Type_typedef typ
     );")
 :doc "Const Definition Class for inspecting properties.")

(type constlist
 :extends    :list
 :allowtypes [const]
 :doc        "List of Const.")

(type constmap
 :extends    :map
 :allowtypes [const]
 :doc        "Map of Const.")

(type context
 :extends    :struct
 :properties [code    : string
              session : session
              setting : setting
              state   : state]
 :doc        "Context")

(type decimal
 :traits     [number]
 :default    0
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_decimal = “0.0”;
     float vx_float() const;
     std::string vx_string() const;"
   :java
    "protected String vxdecimal = “0.0”;

     @Override
     public float vx_float() {
       return Float.parseFloat(vxdecimal);
     }

     @Override
     public String vx_string() {return vxdecimal;}

     @Override
     public Type_decimal vx_new_from_string(final String sval) {
       Class_decimal output = new Class_decimal();
       output.vxdecimal = sval;
       return output;
     }")
 :doc "A clean version of float like Java BigDecimal.")

(type error
 :doc "Error Type")

(type float
 :default 0.0
 :traits  [number]
 :create
  (native
   :cpp
    "// :header
     float vx_p_float = 0;
     float vx_float() const;"
   :java
    "protected float vxfloat = 0;

     @Override
     public float vx_float() {return vxfloat;}

     @Override
     public Type_float vx_new_from_float(final float fval) {
       Class_float output = new Core.Class_float();
       output.vxfloat = fval;
       return output;
     }")
 :test    (test 4.5 (float 4.5))
 :doc     "Standard Floating Point Number")

(type func
 :extends :func
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_funcdef vx_funcdef() const;")
 :doc "Original Function Class.")

(type funcdef
 :extends :struct
 :properties [pkgname : string
              name    : string
              idx     : int
              type    : any
              async   : boolean]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_funcdef vx_funcdef_new(
       std::string pkgname,
       std::string name,
       long idx,
       bool async,
       vx_core::Type_any typ
     );")
 :doc "Func Definition Class for inspecting properties.")

(type funclist
 :extends    :list
 :allowtypes [func]
 :doc        "List of Func.")

(type funcmap
 :extends    :map
 :allowtypes [func]
 :doc        "Map of Func.")

(type int
 :default     0
 :allowvalues [infinity neginfinity]
 :traits      [number]
 :create
  (native
   :cpp
    "// :header
     long vx_p_int = 0;
     long vx_int() const;"
   :java
    "protected int vxint = 0;

     @Override
     public int vx_int() {return vxint;}

     @Override
     public Type_int vx_new_from_int(final int ival) {
       Class_int output = new Core.Class_int();
       output.vxint = ival;
       return output;
     }")
 :test (test-true  (is-int 4))
       (test-true  (is-int "4"))
       (test-true  (is-int infinity))
       (test-true  (is-int neginfinity))
       (test-true  (is-int notanumber))
       (test-false (is-int "a"))
       (test-false (is-int 5.5))
 :doc  "A simple integer.")

(type intlist
 :extends    :list
 :allowtypes [int]
 :doc        "A list of int.")

(type intmap
 :extends    :map
 :allowtypes [int]
 :doc        "A map of int.")

(type list
 :extends    :list
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_listany vx_p_list;
		 vx_core::vx_Type_listany vx_list() const;
     vx_core::Type_any vx_get_any(vx_core::Type_int index) const;
     vx_core::Type_any vx_new_from_list(vx_core::vx_Type_listany listval) const;")
 :doc "A simple untyped list.")

(type listtype
 :extends :type
 :doc     "A generic type that extends :list.")

(type map
 :extends    :map
 :allowtypes [any]
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_mapany vx_p_map;
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;
     vx_core::Type_any vx_new_from_map(vx_core::vx_Type_mapany mapval) const;")
 :doc "A simple untyped map.")

(type maptype
 :extends :type
 :doc     "A generic type that extends :map.")

(type mempool
 :extends    :struct
 :properties [valuepool : value]
 :create
  (native
   :java
    "private int vx_max = 20;

     private Map<String, Deque<Core.Type_any>> vx_maplistany = new ConcurrentHashMap<>();

     @Override
     public <T extends Core.Type_any> T vx_restore(final T generic_any_1) {
       T output = null;
       String typename = Core.f_typename_from_any(generic_any_1).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       if (listany == null) {
       } else if (!listany.isEmpty()) {
         Core.Type_any any = listany.remove();
         if (any != null) {
           output = Core.f_any_from_any(generic_any_1, any);
         }
       }
       return output;
     }

     @Override
     public void vx_recycle(final Core.Type_any addany) {
       String typename = Core.f_typename_from_any(addany).vx_string();
       Deque<Core.Type_any> listany = this.vx_maplistany.get(typename);
       boolean isdestroy = true;
       int imax = this.vx_max;
       if (imax == 0) {
       } else if (listany == null) {
        isdestroy = false;
        listany = new ConcurrentLinkedDeque<Core.Type_any>();
        listany.add(addany);
        this.vx_maplistany.put(typename, listany);
       } else {
        int ilen = listany.size();
        if (ilen < imax) {
          listany.add(addany);
        }
       }
       if (isdestroy) {
         // destroy
       }
     }

     @Override
     public void vx_recyclelist(final List<Core.Type_any> addlistany) {
       for (Core.Type_any addany : addlistany) {
         this.vx_recycle(addany);
       }
     }")
 :doc "Memory Pool")

(type msg
 :extends    :struct
 :properties [code     : string  :doc "Message Code"
              severity : int     :doc "Message Severity"
              text     : string  :doc "Message Text"]
 :create
  (native
   :cpp
    "// :header
     std::exception err;
     vx_core::Type_msg vx_msg_from_errortext(const std::string errortext) const;
     vx_core::Type_msg vx_msg_from_exception(const std::string text, std::exception err) const;"
   :java
    "public Exception err = null;

     public Type_msg vx_new_error(final String text) {
       Class_msg output = new Class_msg();
       output.vx_p_text = Core.t_string.vx_new_from_string(text);
       output.vx_p_severity = Core.c_msg_severe;
       return output;
     }

     public Type_msg vx_new_from_exception(final String text, final Exception err) {
       Class_msg output = new Class_msg();
       output.vx_p_text = Core.t_string.vx_new_from_string(text);
       output.vx_p_severity = Core.c_msg_severe;
       output.err = err;
       Core.debug(output);
       return output;
     }")
 :doc "Message Type for error handling")

(type msgblock
 :extends    :struct
 :properties [msgs      : msglist
              msgblocks : msgblocklist]
 :create
  (native
   :cpp
    "// :header
     vx_core::Type_msgblock vx_msgblock_from_copy_listval(vx_core::Type_msgblock msgblock, vx_core::vx_Type_listany vals) const;"
   :java
    "public Type_msgblock vx_msgblock_from_copy_arrayval(final Core.Type_any copy, final Object... vals) {
       Core.Type_msgblock output = Core.e_msgblock;
       Core.Type_msgblock copymsgblock = copy.vx_msgblock();
       if (copymsgblock != null) {
         output = copymsgblock;
       }
/*
       List<Core.Type_msgblock> listmsgblock = new ArrayList<>();
       List<Core.Type_msg> listmsg = new ArrayList<>();
       for (Object subval : vals) {
         if (subval instanceof Core.Type_msgblock) {
           listmsgblock.add((Core.Type_msgblock)subval);
         } else if (subval instanceof Core.Type_msg) {
           listmsg.add((Core.Type_msg)subval);
         } else if (subval instanceof Core.Type_any) {
           Core.Type_any val = (Core.Type_any)subval;
           Core.Type_msgblock msgblock = val.vx_msgblock();
           if (msgblock == null) {
           } else if (msgblock == Core.e_msgblock) {
           } else {
             listmsgblock.add(msgblock);
           }
         }
       }
       if ((listmsg.size() > 0) || (listmsgblock.size() > 0)) {
         Core.Class_msgblock work = new Core.Class_msgblock();
         if (listmsg.size() > 0) {
           Core.Class_msglist msglist = new Core.Class_msglist();
           msglist.vxlist = listmsg;
           work.vxmsglist = msglist;
         }
         if (listmsgblock.size() > 0) {
           Core.Class_msgblocklist msgblocklist = new Core.Class_msgblocklist();
           msgblocklist.vxlist = listmsgblock;
           work.vxmsgblocklist = msgblocklist;
         }
         output = Core.t_msgblock.vx_copy(output, work);
       }
*/
       return output;
     }")
 :doc "Block of Messages")

(type msgblocklist
 :extends    :list
 :allowtypes [msgblock]
 :doc        "List of Message Blocks")

(type msglist
 :extends    :list
 :allowtypes [msg]
 :doc        "List of Messages")

(type none
 :doc "No Type. No type is returned at all. e.g. Void")

(type notype
 :doc "No Type that allows no Types as a Value")

(type number
 :default    0
 :allowtypes [int float decimal]
 :doc        "A generic number that could be int, float, or decimal.")

(type numberlist
 :allowtypes [number]
 :extends    :list
 :doc        "A list of number.")

(type numbermap
 :allowtypes [number]
 :extends    :map
 :doc        "A map of number.")

(type package
 :extends :struct
 :doc     "A package that store types, consts and funcs.")

(type packagemap
 :extends    :map
 :allowtypes [package])

(type permission
 :extends    :struct
 :properties [id : string]
 :doc        "Permission")

(type permissionlist
 :extends    :list
 :allowtypes [permission]
 :doc        "List of Permission")

(type permissionmap
 :extends    :map
 :allowtypes [permission]
 :doc        "Map of Permission")

(type security
 :extends    :struct
 :properties [permissions   : permissionlist
              permissionmap : permissionmap]
 :doc        "Security rules")

(type session
 :extends    :struct
 :properties [user        : user
              connectlist : connectlist
              connectmap : connectmap]
 :doc        "Session")

(type setting
 :extends    :struct
 :properties [pathmap : stringmap]
 :doc        "Settings")

(type state
 :extends    :map
 :allowtypes [statelistener])

(type statelistener
 :extends     :struct
 :properties
  [path       : string
   value      : any
   fn-boolean : boolean<-none])

(type string
 :extends string
 :default ""
 :create
  (native
   :cpp
    "// :header
     std::string vx_p_string = “”;
     std::string vx_string() const;"
   :java
    "protected String vxstring = “”;

     @Override
     public String vx_string() {
       return vxstring;
     }

     @Override
     public Type_string vx_new_from_string(final String text) {
       Type_string output;
       if (text == “” && Core.e_string != null) {
         output = Core.e_string;
       } else {
         Class_string work = new Core.Class_string();
         work.vxstring = text;
         output = work;
       }
       return output;
     }")
 :test    (test "a" (string "a"))
          (test "ab" (string "a" "b"))
 :doc     "A simple string.")

(type stringlist
 :extends    :list
 :allowtypes [string]
 :doc        "A list of string.")

(type stringmap
 :extends    :map
 :allowtypes [string]
 :doc        "A map of string.")

(type struct
 :extends :struct
 :create
  (native
   :cpp
    "// :header
     vx_core::vx_Type_mapany vx_map() const;
     vx_core::Type_any vx_get_any(vx_core::Type_string key) const;")
 :doc "Struct is the type of all structures/objects with properties.")

(type thenelse
 :extends    :struct
 :properties [code    : string
              value   : any
              values  : list
              fn-cond : boolean<-func
              fn-any  : any<-func])

(type thenelselist
 :extends    :list
 :allowtypes [thenelse])

(type type
 :extends :type
 :doc     "Original Type Class")

(type typedef
 :extends    :struct
 :properties [pkgname        : string
              name           : string
              extends        : string
              allowfuncs     : funclist
              allowtypes     : typelist
              allowvalues    : anylist
              disallowfuncs  : funclist
              disallowtypes  : typelist
              disallowvalues : anylist
              properties     : argmap
              proplast       : arg
              traits         : typelist]
 :create
  (native
   :cpp
    "// :header
     static vx_core::Type_typedef vx_typedef_new(
       std::string pkgname,
       std::string name,
       std::string extend,
       vx_core::Type_typelist traits,
       vx_core::Type_typelist allowtypes,
       vx_core::Type_typelist disallowtypes,
       vx_core::Type_funclist allowfuncs,
       vx_core::Type_funclist disallowfuncs,
       vx_core::Type_anylist allowvalues,
       vx_core::Type_anylist disallowvalues,
       vx_core::Type_argmap properties
     );")
 :doc "Type Definition Class for inspecting Type properties.")

(type typelist
 :extends    :list
 :allowtypes [any]
 :doc        "List of Types")

(type typemap
 :extends    :map
 :allowtypes [any]
 :doc        "Map of Any Type Class")

(type user
 :extends    :struct
 :properties [security : security
              username : string
              token    : string]
 :doc        "User Type")

(type value
 :extends    :struct
 :properties [next : any
              refs : int])

(const false : boolean
 :test (test-false false))

(const globalpackagemap : packagemap)

(const infinity : int
 (native
  :js "Infinity")
 :doc "Infinity. Returned during unusual calculations.")

(const mempool-active : mempool
 :doc "Active Value Memory Pool")

(const msg-info : int
 0
 :doc "Message is just information")

(const msg-warning : int
 1
 :doc "Message is a Warning")

(const msg-error : int
 2
 :doc "Message is an Error")

(const msg-severe : int
 3
 :doc "Message is a Severe Error")

(const neginfinity : int
 (native
  :js "-Infinity")
 :doc "Negative Infinity. Returned during unusual calculations.")

(const newline : string
 "\n"
 :doc "New line constant")

(const notanumber : int
 (native
  :js "NaN")
 :doc "Not a number. Returned during invalid calculations.")

(const nothing : string
 "nothing"
 :doc "Nothing Value. Opposite of every other value. e.g. Nil, Null")

(const quote : string
 "\""
 :doc "Quotation mark constant")

(const true : boolean
 (native
  :js "true"
  :java "true")
 :test (test-true true))

(func . : any
 [object : any
  method : string
  params : anylist :...]
 (native
  :js "object[method].apply(params)")
 :alias       "dotmethod"
 :doc         "Not Recommened: Support for Object Oriented dot notation. e.g. (this.foo 'a') = this.foo('a')"
 :sideeffects "Depends on object")

(func + : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() + num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :js
   "num1 + num2"
  :java
   "int result = num1.vx_int() + num2.vx_int();
    output = Core.t_int.vx_new_from_int(result);")
 :alias "plus"
 :doc   "Math int plus"
 :test  (test 5 (+ 2 3))
        (test 3 (+ 5 -2)))

(func + : number
 [num1 : number
  num2 : number]
 (native
  :js
   "num1 + num2"
  :java
   "Core.Type_float float1 = Core.t_float.vx_new(num1);
    Core.Type_float float2 = Core.t_float.vx_new(num2);
    float result = float1.vx_float() + float2.vx_float();
    output = Core.t_float.vx_new_from_float(result);")
 :alias "plus"
 :test  (test 5 (+ 2  3))
        (test 3 (+ 5 -2))
 :doc   "Math number plus")

(func + : int
 [nums : intlist :...]
 (any<-list-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (+ total num))
 )
 :alias "plus"
 :doc   "Math int plus")

(func + : number
 [nums : numberlist :...]
 (any<-list-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (+ total num))
 )
 :alias "plus"
 :doc   "Math number plus")

(func +1 : int
 [num : int]
 (native
  :cpp
   "long result = num->vx_int() + 1;
    output = vx_core::vx_new_int(result);"
  :js
   "num + 1"
  :java
   "int result = num.vx_int() + 1;
    output = Core.t_int.vx_new_from_int(result);")
 :alias "plus1"
 :test  (test  3 (+1  2))
        (test -1 (+1 -2))
 :doc   "Math int plus 1")

(func - : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() - num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :js
   "num1 - num2"
  :java
   "int result = num1.vx_int() - num2.vx_int();
    output = Core.t_int.vx_new_from_int(result);")
 :alias "minus"
 :doc   "Math int minus"
 :test  (test 1 (- 3 2))
        (test 7 (- 5 -2)))

(func - : number
 [num1 : number
  num2 : number]
 (native
  :js
   "num1 - num2"
  :java
   "Core.Type_float float1 = Core.t_float.vx_new(num1);
    Core.Type_float float2 = Core.t_float.vx_new(num2);
    float result = float1.vx_float() - float2.vx_float();
    output = Core.t_float.vx_new_from_float(result);")
 :alias "minus"
 :doc   "Math number minus"
 :test  (test 5 (+ 2 3))
        (test 3 (+ 5 -2)))

(func - : int
 [nums : intlist :...]
 (any<-list-reduce
  nums
  0
  (fn : int
   [total : int
    num   : int]
   (- total num))
 )
 :alias "minus"
 :doc   "Math integer minus")

(func - : number
 [nums : numberlist :...]
 (any<-list-reduce
  nums
  0
  (fn : number
   [total : number
    num   : number]
   (- total num))
 )
 :alias "minus"
 :doc   "Math number minus")

(func * : int
 [num1 : int
  num2 : int]
 (native
  :cpp
   "long result = num1->vx_int() * num2->vx_int();
    output = vx_core::vx_new_int(result);"
  :js
   "num1 * num2"
  :java
   "int result = num1.vx_int() * num2.vx_int();
    output = Core.t_int.vx_new_from_int(result);")
 :alias "multiply"
 :test  (test 6 (* 3 2))
        (test -10 (* 5 -2))
 :doc   "Math int multiply")

(func * : number
 [num1 : number
  num2 : number]
 (native
  :js
   "num1 * num2"
  :java
   "Core.Type_float float1 = Core.t_float.vx_new(num1);
    Core.Type_float float2 = Core.t_float.vx_new(num2);
    float result = float1.vx_float() * float2.vx_float();
    output = Core.t_float.vx_new_from_float(result);")
 :alias "multiply"
 :test  (test 6.4 (* 3.2 2))
        (test -10.2 (* 5.1 -2))
 :doc   "Math multipy")

(func * : int
 [nums : intlist :...]
 (any<-list-reduce
  nums
  1
  (fn : int
   [total : int
    num   : int]
   (* total num))
 )
 :alias "multiply"
 :test  (test 24 (* 3 2 4))
        (test -20 (* 5 -2 2))
 :doc   "Math multiply")

(func * : number
 [nums : numberlist :...]
 (any<-list-reduce
  nums
  1
  (fn : number
   [total : number
    num   : number]
   (* total num))
 )
 :alias "multiply"
 :test  (test 24 (* 3 2 4))
        (test -20 (* 5 -2 2))
 :doc   "Math multiply")

(func / : number
 [num1 : number
  num2 : number]
 (native
  :js
   "num1 / num2"
  :java
   "Core.Type_float float1 = Core.t_float.vx_new(num1);
    Core.Type_float float2 = Core.t_float.vx_new(num2);
    if (float1.vx_float() == 0) {
    } else if (float2.vx_float() == 0) {
      output = Core.c_notanumber;
    } else {
      float result = float1.vx_float() / float2.vx_float();
      output = Core.t_float.vx_new_from_float(result);
    }")
 :alias "divide"
 :test  (test 3 (/ 6 2))
        (test -5 (/ 10 -2))
 :doc   "Math divide")

(func = : boolean
 [val1 : any
  val2 : any]
 (native
  :cpp
   "bool isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      std::string str1 = vx_core::vx_string_from_any(val1);
      std::string str2 = vx_core::vx_string_from_any(val2);
      if (str1 == str2) {
        isequal = true;
      }
    }
    output = vx_core::vx_new_boolean(isequal);"
  :js
   "const native1 = " (native<-any val1) "
    const native2 = " (native<-any val2) "
    output = true
    if (val1 === val2) {
    } else if (native1 === native2) {
    } else {
      const typename = typeof native1
      switch (typename) {
      case 'number':
        if (isNaN(native1) && isNaN(native2)) {
        } else {
          output = false
        }
        break
      case 'boolean':
      case 'string':
        output = false
        break
      default:
        const type1 = " (type<-any val1) "
        const type2 = " (type<-any val2) "
        const extends1 = " (extends<-typedef type1 :native) "
        const extends2 = " (extends<-typedef type2 :native) "
        if (type1 != type2) {
          output = false
        } else if (extends1 != extends2) {
          output = false
        } else {
          switch (extends1) {
          case ':list':
            if (val1.length !== val2.length) {
              output = false
            } else if (val1.every((val, index) => val === val2[index])) {
              output = true
            } else {
              output = false
            }
            break
          case ':map':
            const keys1 = Object.keys(native1)
            const keys2 = Object.keys(native2)
            if (keys1.length !== keys2.length) {
              output = false
            } else if (keys1.every(key => native1[key] === native2[key])) {
              output = true
            } else {
              output = false
            }
            break
          default:
            output = false
            break
          }
          break
        }
        break
      }
    }"
  :java
   "boolean isequal = false;
    if (val1 == val2) {
      isequal = true;
    } else {
      Core.Type_string strval1 = Core.f_string_from_any(val1);
      Core.Type_string strval2 = Core.f_string_from_any(val2);
      if (strval1.vx_string().equals(strval2.vx_string())) {
        isequal = true;
      }
    }
    output = Core.t_boolean.vx_new_from_boolean(isequal);")
 :alias "eq"
 :doc   "Boolean equal/equivalent"
 :test  (test-true (= true true))
        (test-true (= 2 2))
        (test-true (= "a" "a"))
        (test-true (= (stringlist "a" "b" "c") (new stringlist "a" "b" "c")))
        (test-true (= (stringmap :a "1" :b "2") (new stringmap :a "1" :b "2"))))

(func = : boolean
 [values : anylist :...]
 (any<-list-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (= current next)))
 )
 :alias "eq"
 :doc   "Boolean equal/equivalent"
 :test  (test-false (= 2 2 3)))

/*
(func == : boolean
 [values : anylist :...]
 (native
  :js
   "const firstval = values[0]
    const firstnative = " (native<-any firstval :native) "
    output = true
    for (let i = 1; i < values.length; i++) {
      let value = values[i]
      if (firstval === value) {
      } else if (firstnative === " (native<-any value :native) ") {
      } else {
        output = false
        break
      }
    }"
  :java
   "boolean isequal = true;
    List<Core.Type_any> listvalue = values.vx_list();
    if (listvalue == null) {
    } else if (listvalue.size() > 0) {
      Core.Type_any val = listvalue.get(0);
      for (Core.Type_any subval : listvalue) {
        if (val != subval) {
          isequal = false;
        }
      }
    }
    output = Core.t_boolean.vx_new_from_boolean(isequal);")
 :alias "eqeq"
 :doc   "Strict Boolean equality"
 :test  (test-true (== true true))
        (test-true (== 2 2))
        (test-false (== 2 2 3))
        (test-true (== "a" "a")))
*/

(func ! : boolean
 [val : boolean :doc "Thing to not"]
 (native
  :cpp  "vx_core::vx_new_boolean(!val->vx_boolean());"
  :js   "!val"
  :java "Core.t_boolean.vx_new_from_boolean(!val.vx_boolean());")
 :alias "not"
 :test  (test-false false)
        (test-false (! true))
 :doc   "Boolean not")

(func != : boolean
 [val1 : any
  val2 : any]
 (! (= val1 val2))
 :alias "ne"
 :test  (test-ne true false)
        (test-ne "a" "b")
 :doc   "Returns true if the first arg is not equal to any of the other args")

(func !-empty : boolean
 [text : string]
 (! (is-empty text))
 :alias "notempty"
 :doc   "Returns true if text is not empty.")

(func !-empty : boolean
 [val : any]
 (! (is-empty val))
 :alias "notempty"
 :doc   "Returns true if val is not empty.")

(func < : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case -1 true)
  (else    false))
 :alias "lt"
 :doc   "Returns true if the first arg is less than all of the other args"
 :test  (test-true (< 2 3)))

(func < : boolean
 [values : anylist :...]
 (any<-list-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (< current next)))
 )
 :alias "lt"
 :doc   "Returns true if the first arg is less than all of the other args"
 :test  (test-true (< 2 3))
        (test-true (< "b" "d" "z")))

(func <= : boolean
 [val1 : any
  val2 : any]
 (! (> val1 val2))
 :alias "le"
 :test  (test-true (<= 2 3))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <= : boolean
 [args : anylist :...]
 (! (> args))
 :alias "le"
 :test  (test-true (<= "b" "d" "z"))
 :doc   "Returns true if the first arg is less or equal than all of the other args")

(func <- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainfirst
 :test  (test
         (*
          (+
           (- 5 3)
           3)
          2)
         (<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc   "This is a special function that applies a value as the first argument for the first function.
         The result is then used as the first argument on the next function, etc. Sometimes this
         improves readability.")

(func <<- : any-1
 [value  : any-1
  fnlist : any<-anylist :...]
 :alias chainlast
 :test  (test
         (* (+ (- 3 5) 3) 2)
         (<<-
          5
          (- 3)
          (+ 3)
          (* 2)))
 :doc   "This is a special function that applies a value as the last argument for the first function.
         The result is then used as the last argument on the next function, etc. Sometimes this
         improves readability.")

(func > : boolean
 [val1 : any
  val2 : any]
 (switch
  (compare val1 val2)
  (case 1 true)
  (else   false))
 :alias "gt"
 :test  (test-true (> 3 2))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func > : boolean
 [values : anylist :...]
 (any<-list-reduce-next : boolean
  values
  true
  (fn : boolean
   [reduce  : boolean
    current : any
    next    : any]
   (and reduce (> current next)))
 )
 :alias "gt"
 :test  (test-true (> "z" "y" "b"))
 :doc   "Returns true if the first arg is greater than all of the other args")

(func >= : boolean
 [val1 : any
  val2 : any]
 (! (< val1 val2))
 :alias "ge"
 :test  (test-true (>= 3 2))
 :doc   "Returns true if val1 is greater or equal to val2")

(func >= : boolean
 [args : anylist :...]
 (! (< args))
 :alias "ge"
 :test  (test-true (>= "z" "b" "b"))
 :doc   "Returns true if the first arg is greater or equal than all of the other args")

(func allowtypenames<-typedef : stringlist
 [vtypedef : typedef]
 (typenames<-typelist (allowtypes<-typedef vtypedef))
 :doc "Return allow name list from type")

(func allowtypes<-typedef : typelist
 [vtypedef : typedef]
 (native
  :js
   "vtypedef['vx_value']['allowtypes']"
  :java
   "vtypedef.allowtypes();")
 :doc "Return allow type list from type")

(func and : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :js
   "if (val1 && val2) {
      output = true
    } else {
      output = false
    }"
  :java
   "if (val1.vx_boolean() && val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }")
 :doc   "Returns true if all values are true"
 :test  (test-true (and true true))
        (test-false (and true false)))

(func and : boolean
 [values : booleanlist :...]
 (switch : boolean
  (length<-list values)
  (case 0 true)
  (case 1 (:0 values))
  (else
   (any<-list-reduce-next : boolean
    values
    true
    (fn : boolean
     [reduce  : boolean
      current : boolean
      next    : boolean]
     (and reduce (and current next)))
   )))
 :doc   "Returns true if all values are true"
 :test  (test-true (and true true true))
        (test-false (and true true false)))

(func any<-any : any-1
 [value : any-2]
 (native
  :cpp
   "output = vx_core::vx_any_from_any(generic_any_1, value);"
  :js
   "value"
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;")
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-async : any-1
 [value : any-2]
 :async
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-any-context : any-1
 [value : any-2]
 (native
  :java
   "@SuppressWarnings(“unchecked”)
    output = (T)value;")
 :context
 :doc "Function Type taking any value any-2 and returning generic any-1 using context")

(func any<-any-context-async : any-1
 [value : any-2]
 :async
 :context
 :doc "Function Type taking any value any-2 and returning generic any-1")

(func any<-func : any-1
 []
 :doc "Function Type returning Generic any-1 with any parameters")

(func any<-func-async : any-1 :async
 []
 :doc "Function Type returning Generic any-1 with any parameters")

(func any<-key-value : any-1
 [key : string
  val : any-2])

(func any<-key-value-async : any-1 :async
 [key : string
  val : any-2])

(func any<-list : any-1
 [values : list-1
  index  : int]
 (native
  :js
   "if (index < values.length) {
      output = values[index]
    }"
  :java
   "int intindex = index.vx_int();
    int intsize = values.vx_list().size();
    if (intindex < intsize) {
      List<Core.Type_any> listvalue = values.vx_list();
      Core.Type_any value = listvalue.get(intindex);
      output = Core.f_any_from_any(generic_any_1, value);
    }")
 :test (test
        "b"
        (any<-list (list "a" "b" "c") 1))
       (test
        "b"
        (:1 (stringlist "a" "b" "c")))
 :doc "Returns nth value from a list or none if out of bounds")

(func any<-list-reduce : any-1
 [list      : list-2
  valstart  : any-1
  fn-reduce : any<-reduce]
 (native
  :cpp
   "vx_core::Type_any work = valstart;
    std::vector<vx_core::Type_any> listval = list->vx_list();
    for (vx_core::Type_any item : listval) {
      work = fn_reduce->vx_any_from_reduce(work, item);
    };
    output = vx_core::vx_any_from_any(generic_any_1, work);"
  :js
   "output = valstart
    const fn = fn_reduce['vx_value']
    if (fn) {
      for (const item of list) {
        output = fn(output, item)
      }
    }"
  :java
   "output = valstart;
    List<Core.Type_any> listval = list.vx_list();
    for (Core.Type_any item : listval) {
      output = fn_reduce.f_any_from_reduce(generic_any_1, output, item);
    }")
 :test (test
        24
        (any<-list-reduce : int
         (intlist 3 2 4)
         1
         (fn : int
          [total : int
           num   : int]
          (* total num))
        ))
 :doc "Returns a val from a list reduce operation")

(func any<-list-reduce-next : any-1
 [list           : list-2
  valstart       : any-1
  fn-reduce-next : any<-reduce-next]
 (native
  :js
   "output = valstart
    const fn = fn_reduce_next['vx_value']
    if (fn) {
      let current = vx_core.t_any
      let first = true
      for (const next of list) {
        if (first) {
          first = false
        } else {
          output = fn(output, current, next)
        }
        current = next
      }
    }"
  :java
   "output = valstart;
    final List<Core.Type_any> listval = list.vx_list();
    Core.Type_any current = Core.t_any;
    boolean first = true;
    for (final Core.Type_any next : listval) {
      if (first) {
        first = false;
      } else {
        output = fn_reduce_next.f_any_from_reduce_next(generic_any_1, output, current, next);
      }
      current = next;
    }")
 :doc "Returns a val from a list reduce operation")

(func any<-map : any-1
 [valuemap : map-1
  key      : string]
 (native
  :js
   "if (key.startsWith(':')) {
      key = key.substring(1)
    }
    const mapval = valuemap['vx_value']
    let val = mapval[key]
    if (val != undefined) {
      output = val
    }"
  :java
   "Core.Type_any val = valuemap.vx_map().getOrDefault(key.vx_string(), output);
    output = Core.f_any_from_any(generic_any_1, val);")
 :test (test
        "v2"
        (any<-map (map :a "v1" :b "v2" :c "v3") :b))
 :doc "Returns value from a map or empty if not found")

(func any<-none : any-1
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-none-async : any-1 :async
 []
 :doc "Function Type returning Generic any-1 with no parameters")

(func any<-reduce : any-1
 [result : any-1
  item   : any-2])

(func any<-reduce-async : any-1 :async
 [result : any-1
  item   : any-2])

(func any<-reduce-next : any-1
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-reduce-next-async : any-1 :async
 [result  : any-1
  current : any-2
  next    : any-2])

(func any<-struct : any-1
 [vstruct : struct-2
  key    : string]
 (native
  :js
   "const subvalmap = vstruct['vx_value']
    if (subvalmap != undefined) {
      if (key.startsWith(':')) {
        key = key.substring(1)
      }
      const val = subvalmap[key]
      if (val != undefined) {
        output = val
      }
    }"
  :java
   "Core.Type_any val = vstruct.vx_any(key);
    output = Core.f_any_from_any(generic_any_1, val);")
 :doc "Returns value from a struct")

(func async : any-1 :async
 [value : any-1]
 (native
  :js
   "value"
  :java
   "output = Core.async_new_completed(value);")
 :doc "Returns an asynchonous version value. This exists mostly for type-casting.")

(func boolean<-any : boolean
 [value : any-1]
 :doc "Function Type taking generic any-2 and returning boolean")

(func boolean<-func : boolean
 []
 :doc "Function Type returning boolean with any parameters")

(func boolean<-none : boolean
 []
 :doc "Function Type returning boolean with no parameters")

(func case : thenelse
 [values : list-1
  fn-any : any<-func]
 (thenelse
  :code   :casemany
  :values values
  :fn-any fn-any))

(func case : thenelse
 [value  : any-1
  fn-any : any<-func]
 (thenelse
  :code   :case
  :value  value
  :fn-any fn-any))

(func compare : int
 [val1 : any
  val2 : any]
 (native
  :js
   "if (val1 == val2) {
      output = 0
    } else if (val1 < val2) {
      output = -1
    } else {
      output = 1
    }"
  :java
   "int intresult = 0;
    if ((val1 instanceof Core.Type_number) && (val2 instanceof Core.Type_number)) {
      Core.Type_number num1 = (Core.Type_number)val1;
      Core.Type_number num2 = (Core.Type_number)val2;
      float float1 = Core.t_float.vx_new(num1).vx_float();
      float float2 = Core.t_float.vx_new(num2).vx_float();
      if (float1 < float2) {
        intresult = -1;
      } else if (float1 > float2) {
        intresult = 1;
      }
    } else {
      String stringval1 = Core.f_string_from_any(val1).vx_string();
      String stringval2 = Core.f_string_from_any(val2).vx_string();
      int compare = stringval1.compareTo(stringval2);
      if (compare > 0) {
        intresult = 1;
      } else if (compare < 0) {
        intresult = -1;
      }
    }
    output = Core.t_int.vx_new_from_int(intresult);")
 :test (test 1 (compare 3 2))
       (test 1 (compare "z" "a"))
 :doc "Returns 0 if vals are equal, 1 if val1 > val2, -1 if val1 < val2")

(func contains : boolean
 [text : string
  find : string]
 (native
  :js
   "text.includes(find)"
  :java
   "boolean booleanresult = false;
    String stext = text.vx_string();
    String sfind = find.vx_string();
    booleanresult = stext.contains(sfind);
    output = Core.t_boolean.vx_new_from_boolean(booleanresult);")
 :test (test-true  (contains "abcde" "cd"))
       (test-false (contains "abcde" "dc"))
 :doc  "Returns true if the given list contains the given value.")

(func contains : boolean
 [values : list-2 :doc "Any list"
  find   : any    :doc "Any value"]
 (native
  :cpp
   "bool booleanresult = false;
    vx_core::vx_Type_listany listvalues = values->vx_list();
    for (vx_core::Type_any item : listvalues) {
      vx_core::Type_boolean iseq = vx_core::f_eq(item, find);
      if (iseq->vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = vx_core::vx_new_boolean(booleanresult);"
  :js
   "values.includes(find)"
  :java
   "boolean booleanresult = false;
    List<Core.Type_any> listvalues = values.vx_list();
    for (Core.Type_any item : listvalues) {
      Core.Type_boolean iseq = Core.f_eq(item, find);
      if (iseq.vx_boolean()) {
        booleanresult = true;
        break;
      }
    }
    output = Core.t_boolean.vx_new_from_boolean(booleanresult);")
 :test (test-true  (contains (stringlist "1" "2" "3") "2"))
       (test-true  (contains (intlist 1 2 3) 2))
       (test-false (contains (list 1 "2" 3) 2))
 :doc  "Returns true if the given list contains the given value.")

(func copy : any-1
 [value  : any-1
  values : anylist :...]
 (native
  :cpp
   "T* output = vx_core::vx_copy(value, values->vx_list());"
  :js
   "vx_core.f_new(value, ...values)"
  :java
   "@SuppressWarnings(“unchecked”)
    Core.Type_any[] arrayany = Core.arrayany_from_anylist(values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(value.vx_copy(arrayobj));")
 :doc "Returns a copy of a given value with the given values added or updated.")

(func else : thenelse
 [fn-any : any<-func]
 (thenelse
  :code   :else
  :fn-any fn-any))

(func empty : any-1
 [type : any-1]
 (native
  :cpp
   "T* output = vx_core::vx_any_from_any(type, type->vx_empty());"
  :js
   "const typedef = vx_core.f_typedef_from_type(type)
    const pkgname = typedef['vx_value'].pkgname
    const typename = typedef['vx_value'].name
    const pkg = vx_core.f_global_package_get(pkgname)
    output = pkg.c_empty[typename]"
  :java
   "@SuppressWarnings(“unchecked”)
    T output = (T)(type.vx_empty());")
 :test (test ""     (empty string))
       (test (list) (empty list))
       (test (map)  (empty map))
 :doc "Returns the empty value for a given type. Can be called using (empty type) or simply (type)")

(func extends<-any : string
 [val : any-1]
 (extends<-typedef (typedef<-any val)))

(func extends<-typedef : string
 [vtypedef : typedef]
 (:extends vtypedef)
 :doc "Get the basetype of a given type")

(func first<-list : any-1
 [values : list-1]
 (any<-list values 0)
 :doc "Returns first value"
 :test (test "b" (first<-list (stringlist "b" "c"))))

(func first<-list-fn-any<-any : any-1
 [values      : list-1
  fn-any<-any : any<-any]
 (native
  :js
   "output = " nothing "
    const fn = fn_any_from_any['vx_value']
    if (fn) {
      for (let index=0;index < values.length;index++) {
        output = fn(generic, values[index])
        if (output != " nothing ") {
          break
        }
      }
    }"
  :java
   "List<Core.Type_any> listvalue = values.vx_list();
    for (Core.Type_any value : listvalue) {
      if (value != Core.c_nothing) {
        output = fn_any_from_any.f_any_from_any(generic_any_1, value);
        break;
      }
    }")
 :doc "Returns first value that is not nothing"
 :test (test "b" (first<-list-fn-any<-any (list nothing "b" "c") resolve)))

/*
(func float<-any : float
 [value : any-1]
 (native
  :java
   "float num = 0;
    if (value instanceof Core.Type_int) {
      Core.Type_int valint = (Core.Type_int)value;
      num = valint.vx_int();
    } else if (value instanceof Core.Type_float) {
      Core.Type_float valfloat = (Core.Type_float)value;
      num = valfloat.vx_float();
    }
    output = Core.t_float.vx_new_from_float(num);")
 :doc "Function Type taking generic any_1 and returning float")
*/

(func fn : any-1
 [params : arglist
  fn-any : any<-func]
 :doc "Shell for lambda function calls")

(func funcdef<-func : funcdef
 [val : func]
 (native
  :cpp
   "val->vx_funcdef();"
  :java
   "val.vx_funcdef();"))

(func funcname<-funcdef : string
 [funcdef : funcdef]
 (string (:pkgname funcdef) "/" (:name funcdef))
 :doc "Get the name of a given funcdef")

(func global-package-get : package
 [pkgname : string]
 (native
  :js
   "vx_core.c_globalpackagemap[pkgname]"))

(func global-package-set : none
 [pkgname : string
  pkg : package]
 (native
  :js
   "vx_core.c_globalpackagemap[pkgname] = pkg")
 :sideeffects "Changes globalpackagemap")

(func if : any-1
 [clause : boolean
  then   : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = then;
    }"
  :js
   "if (clause) {
      output = then
    }"
  :java
   "if (clause.vx_boolean()) {
      output = then;
    }")
 :test (test "a" (if (= 2 2) "a"))
       (test ""  (if : string (= 1 2) "a"))
 :doc  "Logical If function")

(func if : any-1
 [clause  : boolean
  thenval : any-1
  elseval : any-1]
 (native
  :cpp
   "if (clause->vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }"
  :js
   "if (clause) {
      output = thenval
    } else {
      output = elseval
    }"
  :java
   "if (clause.vx_boolean()) {
      output = thenval;
    } else {
      output = elseval;
    }")
 :test (test "a" (if (= 2 2) "a" "b"))
       (test "b"  (if (= 1 2) "a" "b"))
 :doc  "Logical If function")

(func if : any-1
 [thenelselist : thenelselist :...]
 (native
  :cpp
   "vx_core::Type_any any = vx_core::vx_if_thenelselist(generic_any_1, thenelselist);
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :js
   "let fn_any = null
    for (const thenelseval of thenelselist) {
      const thenelse = thenelseval['vx_value']
      const code = thenelse['code']
      switch (code) {
      case ':then':
        const fn_cond = thenelse['fn-cond']
        const fn = fn_cond['vx_value']
        const cond = fn()
        if (cond == true) {
          fn_any = thenelse['fn-any']
        }
        break
      case ':else':
        fn_any = thenelse['fn-any']
        break
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        output = fn()
        break
      }
    }"
  :java
   "Core.Func_any_from_func fn_any = Core.Class_list.vx_any_first_from_list_fn(Core.t_any_from_func, thenelselist, (any) -> {
      Core.Func_any_from_func fnany = null;
      if (any instanceof Core.Type_thenelse) {
        Core.Type_thenelse thenelse = (Core.Type_thenelse)any;
        Core.Type_string code = thenelse.code();
        switch (code.vx_string()) {
        case “:then”:
          Core.Func_boolean_from_func fn_cond = thenelse.fn_cond();
          Core.Type_boolean cond = fn_cond.f_boolean_from_func();
          if (cond.vx_boolean() == true) {
            fnany = thenelse.fn_any();
          }
          break;
        case “:else”:
          fnany = thenelse.fn_any();
          break;
        }
      }
      return fnany;
    });
    if (fn_any != null) {
      output = fn_any.f_any_from_func(generic_any_1);
    }")
 :doc  "Logical If function"
 :test (test-true
        (if
         (then (= 2 3) false)
         (then (!= 3 3) false)
         (else (! false)))))

(func int<-func : int
 []
 :doc "Function Type returning int with any parameters")

(func int<-string : int
 [val : string]
 (switch : int
  val
  (case "notanumber"  notanumber)
  (case "infinity"    infinity)
  (case "neginfinity" neginfinity)
  (else
   (native
    :cpp
     "// :capture val
      vx_core::Type_int intresult = vx_core::e_int();
      try {
        std::string sval = val->vx_string();
        long ival = std::stoll(sval);
        intresult = vx_core::vx_new_int(ival);
      } catch (std::exception ex) {
        intresult = vx_core::c_notanumber();
      }
      return intresult;"
    :js
     "parseInt(val)"
    :java
     "int intresult = 0;
      String strval = val.vx_string();
      try {
        float floatresult = Float.parseFloat(strval);
        intresult = (int)floatresult;
        return Core.t_int.vx_new_from_int(intresult);
      } catch (Exception ex) {
        return Core.c_notanumber;
      }"
    )
  )
 )
 :test (test 4 (int<-string "4"))
       (test 5 (int<-string "5.4"))
       (test 5 (int<-string "5.9"))
       (test notanumber  (int<-string "notanumber"))
       (test infinity    (int<-string "infinity"))
       (test neginfinity (int<-string "neginfinity"))
 :doc  "Function Type converting string to int")

(func is-empty : boolean
 [text : string]
 (native
  :cpp
   "if (text->vx_string().length() == 0) {
      output = vx_core::c_true();
    }"
  :js
   "if (text.length == 0) {
      output = vx_core.c_true
    }"
  :java
   "if (text.vx_string().length() == 0) {
      output = Core.c_true;
    }")
 :doc "Returns true if text is empty.")

(func is-empty : boolean
 [value : any]
 (native
  :cpp
   "if (value == value->vx_empty()) {
      output = vx_core::c_true();
    }"
  :js
   "const type = vx_core.f_type_from_any(value)
    if (value == vx_core.f_empty(type)) {
      output = vx_core.c_true
    } else {
      output = vx_core.c_false
    }"
  :java
   "if (value == value.vx_empty()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }")
 :test (test-true (is-empty ""))
       (test-true (is-empty (list)))
       (test-true (is-empty (map)))
 :doc "Returns true if an value is empty")

(func is-endswith : boolean
 [text : string
  find : string]
 (native
  :cpp
   "std::string stext = text->vx_string();
    std::string sfind = find->vx_string();
    if (vx_core::vx_boolean_from_string_ends(stext, sfind)) {
      output = vx_core::c_true();
    }"
  :js
   "if (text.endsWith(find)) {
      output = vx_core.c_true
    }"
  :java
   "String stext = text.vx_string();
    String sfind = find.vx_string();
    if (stext.endsWith(sfind)) {
      output = Core.c_true;
    }")
 :doc "Returns true if text ends with find.")

(func is-func : boolean
 [val : any]
 (native
  :cpp
   "vx_core::Type_string extend = " (extends<-any val) ";
    if (extend->vx_string() == “:func”) {
      output = vx_core::c_true();
    }"
  :js
   "const extend = " (extends<-any val) "
    if (extend == ':func') {
      output = vx_core.c_true
    }"
  :java
   "if (val instanceof Core.Type_func) {
      output = Core.c_true;
    }")
 :doc "Returns true if val is a function.")

(func is-int : boolean
 [value : any]
 (native
  :js
   "output = false
    switch (value) {
    case " infinity ":
    case " neginfinity ":
    case " notanumber ":
      output = true
      break
    default:
      const typename = " (typename<-any value) "
      switch (typename) {
      case 'vx/core/int':
        output = true
        break
      case 'vx/core/number':
        if (parseInt(value) == value) {
          output = true
        }
        break
      case 'vx/core/string':
        if (parseInt(value) == parseFloat(value)) {
          output = true
        }
        break
      }
      break
    }"
  :java
   "boolean result = false;
    if (value == " infinity ") {
      result = true;
    } else if (value == " neginfinity ") {
      result = true;
    } else if (value == " notanumber ") {
      result = true;
    } else if (value instanceof Core.Type_int) {
      result = true;
    } else if (value instanceof Core.Type_float) {
      Core.Type_float valfloat = (Core.Type_float)value;
      float floatval = valfloat.vx_float();
      if ((int)floatval == floatval) {
        result = true;
      }
    } else if (value instanceof Core.Type_decimal) {
      Core.Type_decimal valdec = (Core.Type_decimal)value;
      String strval = valdec.vx_string();
      try {
        if (Integer.parseInt(strval) == Float.parseFloat(strval)) {
          result = true;
        }
      } catch (Exception ex) {
      }
    } else if (value instanceof Core.Type_string) {
      Core.Type_string valstr = (Core.Type_string)value;
      String strval = valstr.vx_string();
      try {
        if (Integer.parseInt(strval) == Float.parseFloat(strval)) {
          result = true;
        }
      } catch (Exception ex) {
      }
    }
    output = Core.t_boolean.vx_new_from_boolean(result);")
 :doc "Returns true if the value is an integer.")

(func is-number : boolean
 [value : any]
 (switch : boolean
  (typename<-any value)
  (case (list
         "vx/core/decimal"
         "vx/core/float"
         "vx/core/int"
         "vx/core/number") true)
  (else false))
 :test (test-true  (is-number 5))
       (test-true  (is-number 5.5))
       (test-false (is-number "a"))
 :doc "Return true if val is a number")

(func is-pass<-permission : boolean
 [permission : permission]
 (let : boolean
  [id     : string     := (:id permission)
   lookup : permission := (permission<-id-context id)]
  (= lookup permission))
 :context
 :doc "Returns true if permission passes.")

(func last<-list : any-1
 [values : list-1]
 (let
  [len  : int := (length<-list values)
   last : int := (- len 1)]
  (any<-list values last))
 :doc  "Returns last value"
 :test (test "c" (last<-list (list "b" "c"))))

(func length<-list : int
 [values : list-1]
 (native
  :cpp
   "int len = values->vx_p_list.size();
    if (len > 0) {
      output = vx_core::vx_new_int(len);
    }"
  :js "values.length"
  :java
   "int intresult = values.vx_list().size();
    output = Core.t_int.vx_new_from_int(intresult);")
 :doc "Returns the currently used size/length of a list"
 :test (test 3 (length<-list (stringlist "a" "b" "c"))))

(func let : any-1
 [args   : arglist
  fn-any : any<-func :: any-1]
 (native
  :cpp
   "vx_core::Type_any any = fn_any->vx_any_from_func();
    output = vx_core::vx_any_from_any(generic_any_1, any);"
  :js
   "const fn = fn_any['vx_value']
    if (fn) {
      output = fn()
    }"
  :java
   "fn_any.f_any_from_func(generic_any_1);")
 :test (test
        7
        (let
         [v1 : int := 2
          v2 : int := (+ v1 3)]
         (+ v1 v2))))

(func let-async : any-1 :async
 [args         : arglist
  fn-any-async : any<-func-async]
 (native
  :cpp
   "fn_any_async->vx_any_from_func_async(generic_any_1);"
  :js
   "const fn = fn_any_async['vx_value']
    if (fn) {
      output = await fn()
    }"
  :java
   "fn_any_async.f_any_from_func_async(generic_any_1);")
 :doc "Same as normal let but returns async values.")

(func list<-list : list-1
 [values      : list-2
  fn-any<-any : any<-any]
 (native
  :js
   "const fn = fn_any_from_any['vx_value']
    if (fn) {
      output = values.map(fn)
      output['vx_type'] = generic_list_1
    }"
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any.f_any_from_any(generic_list_1, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));")
 :doc "Returns a list of processed items from another list")

(func list<-list-async  : list-1 :async
 [values                : list-2
  fn-any<-any-async : any<-any-async]
 (native
  :js
   "const fn = fn_any_from_any_async['vx_value']
    if (fn) {
      const listfuture = values.map(fn)
      const future = Promise.all(listfuture)
      output = await future
      output['vx_type'] = generic_list_1
    }"
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<CompletableFuture<Core.Type_any>> list_async_result = Core.arraylist_from_arraylist_fn(list_value, (val) -> {
      return fn_any_from_any_async.f_any_from_any_async(generic_list_1, val);
    });
    CompletableFuture<List<Core.Type_any>> async_list_result = Core.async_arraylist_from_arraylist_async(list_async_result);
    output = Core.async_from_async_fn(async_list_result, (list_result) -> {
      X work = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));
      return work;
    });")
 :doc "Returns an asynchronous list of the processed asynchronous items from another list")

(func list-join<-list : list-1
 [values      : list-2
  fn-any<-any : any<-any]
 (native
  :js
   "const fn = fn_any_from_any['vx_value']
    if (fn) {
      const listoflist = values.map(fn)
      output = listoflist.flat()
      output['vx_type'] = generic_list_1
    }"
  :java
   "List<Core.Type_any> list_value = values.vx_list();
    List<Core.Type_any> list_result = new ArrayList<>();
    for (Core.Type_any val : list_value) {
      Core.Type_any listoflist = fn_any_from_any.f_any_from_any(generic_list_1, val);
      if (listoflist instanceof Core.Type_list) {
        Core.Type_list vallist = (Core.Type_list)listoflist;
        List<Core.Type_any> listval = vallist.vx_list();
        list_result.addAll(listval);
      }
    }
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(list_result));")
 :doc "Returns a flattened list of processed items from another list")

(func list<-map : list-1
 [valuemap           : map-2
  fn-any<-key-value  : any<-key-value]
 (native
  :js
   "const fn = fn_any_from_key_value['vx_value']
    if (fn) {
      const entries = Object.entries(valuemap['vx_value'])
      const values = entries.map(fn)
      output = vx_core.f_new(generic_list_1, ...values)
    }"
  :java
   "Map<String, Core.Type_any> map_value = valuemap.vx_map();
    List<Core.Type_any> listresult = Core.arraylist_from_linkedhashmap_fn(map_value, (key, val) -> {
      Core.Type_string valkey = Core.t_string.vx_new_from_string(key);
      return fn_any_from_key_value.f_any_from_key_value(Core.t_any, valkey, val);
    });
    output = Core.f_any_from_any(generic_list_1, generic_list_1.vx_new(listresult));")
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap "a" "1" "b" "2")
         (fn : string
          [key : string
           val : string]
          (string key val))))
 :doc "Returns a list from a map by applying a function to each key value.")

(func list<-map-async : list-1 :async
 [valuemap                : map-2
  fn-any<-key-value-async : any<-key-value-async])

(func list<-type : any
 [type : any]
 (native
  :js
   "output = []
    output['vx_type'] = type")
 :doc "Create an empty list from a type. Used internally for default lists")

(func log : any
 [value : any]
 (native
  :cpp
   "vx_core::vx_debug(value);
    output = value;"
  :js
   "const text = vx_core.f_string_from_any(value)
    console.log(text)
    output = value"
  :java
   "Core.Type_string stringtext = Core.f_string_from_any(value);
    String text = stringtext.vx_string();
    System.out.println(text);
    output = value;"))

(func map<-list : map-1
 [vallist      : list-2
  fn-any<-any  : any<-any :: string]
 (native
  :cpp
   "vx_core::vx_Type_listany listval = vallist->vx_list();
    vx_core::vx_Type_mapany mapval = vx_core::vx_map_from_list(listval);
    output = vx_core::vx_new_from_map(generic_map_1, mapval);"
  :js
   "const valmap = {}
    vallist.map(value => {
      const fn = fn_any_from_any['vx_value']
      if (fn) {
        const key = fn(value)
        valmap[key] = value
      }
    })
    output = {
      vx_type: generic_map_1,
      vx_value: valmap
    }"
  :java
   "List<Core.Type_any> listval = vallist.vx_list();
    Map<String, Core.Type_any> mapresult = Core.map_from_list_fn(listval, (val) -> {
      return fn_any_from_any.f_any_from_any(Core.t_string, val);
    });
    output = Core.f_any_from_any(generic_map_1, output.vx_new_from_map(mapresult));")
 :test (test
        (stringlist "a1" "b2")
        (list<-map : stringlist
         (stringmap "a" "1" "b" "2")
         (fn : string
          [key : string
           val : string]
          (string key val))))
 :doc "Returns a list from a map by applying a function to each key value.")

(func mempool-addref : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const value = values[i]
      if (value.refs) {
        value.refs += 1
      }
    }")
 :doc "Add Value Reference")

(func mempool-reserve : value
 []
 (native
  :js
   "mempool = " mempool-active "
    output = mempool.valuepool
    if (output == null) {
      output = {
        refs: 0
      }
    } else {
      const next = output.next
      if (next == null) {
        mempool.valuepool = null
      } else {
        mempool.valuepool = next
        output.next = null
      }
    }")
 :doc "Returns a recycled Value or creates a new one.")

(func mempool-release : none
 [value : value]
 (native
  :js
   "const mempool = " mempool-active "
    value.length = 0
    for (const key in value) {
      delete value[key]
    }
    next = mempool.valuepool
    value.next = next
    mempool.valuepool = value")
 :doc "Recycles a Value and adds it to the valuepool.")

(func mempool-removeref : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const value = values[i]
      if (value.refs) {
        value.refs -= 1
        if (value.refs == 0) {
          vx_core.f_mempool_removerefchildren(value)
          vx_core.f_mempool_recyclevalue(value)
        }
      }
    }")
 :doc "Remove Value Reference")

(func mempool-removerefchildren : none
 [values : anylist :...]
 (native
  :js
   "for (const value of values) {
      const extend = " (extends<-any value) "
      switch (extend) {
      case ':list':
        vx_core.f_mempool_removeref(...value['vx_value'])
        break
      case ':map':
      case ':struct':
        vx_core.f_mempool_removeref(...Object.entities(value['vx_value']))
        break
      }
    }")
 :doc "Remove Value Child References")

(func msg<-error : msg
 [error : string]
 (msg
  :severity msg-error
  :text error)
 :doc "Returns a msg from error string")

(func msgblock<-msgblock-msg : msgblock
 [origblock : msgblock
  addmsg    : msg]
 (copy origblock addmsg)
 :doc "Return a new Msgblock with the added msg")

(func msgblock<-msgblock-msgblock : msgblock
 [origblock : msgblock
  addblock  : msgblock]
 (msgblock origblock addblock)
 :doc "Return a new Msgblock with the added block")

(func name<-typedef : string
 [vtypedef : typedef]
 (:name vtypedef)
 :doc "Returns the name from a typedef.")

(func native : any-1
 [clauses : anylist :...]
 :doc "Native Function Call")

(func native<-any : any
 [value : any-1]
 (native
  :js
   "output = value
    switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'string':
      break
    default:
      const extend = " (extends<-any value) "
      switch (extend) {
      case ':list':
        output = [...value]
        break
      case ':func':
      case ':map':
      case ':struct':
        output = value['vx_value']
        break
      }
      break
    }")
  :doc "Returns native value of value object")

(func new : any-1
 [type   : any-1
  values : anylist :...]
 (native
  :cpp
   "T* output = vx_core::vx_new(type, values->vx_list());"
  :js
   "const typedef = vx_core.f_typedef_from_any(type)
    const copy = type
    let msgblock = vx_core.e_msgblock
    if (values.length == 1) {
      // check if anylist passed as the only value
      const val1 = values[0]
      const val1typedef = val1['vx_type']
      if (val1typedef == undefined) {
      } else if (val1typedef == vx_core.t_anylist) {
        values = val1
      }
    }
    let isfirst = true
    switch (typedef) {
    case vx_core.t_boolean:
      output = false
      if (type == vx_core.t_boolean) {
      } else if ((typeof copy) == 'boolean') {
        output = copy
      } else {
        output = copy['vx_value']
        const testmsgblock = copy['vx_msgblock']
        if (testmsgblock != undefined) {
          msgblock = testmsgblock
        }
      }
      values.map(value => {
        switch (typeof value) {
        case 'boolean':
          if (isfirst) {
            isfirst = false
            output = value
          } else {
            output = output && value
          }
          break
        default:
          const valuetype = vx_core.f_typedef_from_any(value)
          switch (valuetype) {
          case vx_core.t_boolean:
            value = value['vx_value']
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output = output && value
            }
            break
          case vx_core.t_msgblock:
            msgblock = value
            break
          case vx_core.t_msg:
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
            break
          default:
            const typename = vx_core.f_typename_from_typedef(typedef)
            const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
            break
          }
          break
        }
      })
      if (msgblock != vx_core.e_msgblock) {
        output = {
          vx_type: typedef,
          vx_value: output,
          vx_msgblock: msgblock
        }
      }
      break
    case vx_core.t_int:
      output = 0
      if (type == vx_core.t_int) {
      } else if ((typeof copy) == 'number') {
        output = copy
      } else {
        output = copy['vx_value']
        const testmsgblock = copy['vx_msgblock']
        if (testmsgblock != undefined) {
          msgblock = testmsgblock
        }
      }
      values.map(value => {
        switch (typeof value) {
        case 'number':
          if (isfirst) {
            isfirst = false
            output = value
          } else {
            output += value
          }
          break
        case 'string':
          value = parseFloat(value)
          if (isfirst) {
            isfirst = false
            output = value
          } else {
            output += value
          }
          break
        default:
          const valuetype = vx_core.f_type_from_any(value)
          switch (valuetype) {
          case vx_core.t_int:
            value = value['vx_value']
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output = output + value
            }
            break
          case vx_core.t_float:
            value = value['vx_value']
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output += value
            }
            break
          case vx_core.t_string:
            value = parseFloat(value)
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output += value
            }
            break
          case vx_core.t_msgblock:
            msgblock = value
            break
          case vx_core.t_msg:
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
            break
          default:
            const typename = vx_core.f_typename_from_typedef(typedef)
            const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
            break
          }
          break
        }
      })
      output = Math.round(output)
      if (msgblock != vx_core.e_msgblock) {
        output = {
          vx_type: typedef,
          vx_value: output,
          vx_msgblock: msgblock
        }
      }
      break
    case vx_core.t_float:
      output = 0.0
      if (type == vx_core.t_float) {
      } else if ((typeof copy) == 'number') {
        output = copy
      } else {
        output = copy['vx_value']
        const testmsgblock = copy['vx_msgblock']
        if (testmsgblock != undefined) {
          msgblock = testmsgblock
        }
      }
      values.map(value => {
        switch (typeof value) {
        case 'number':
          if (isfirst) {
            isfirst = false
            output = value
          } else {
            output += value
          }
          break
        case 'string':
          value = parseFloat(value)
          if (isfirst) {
            isfirst = false
            output = value
          } else {
            output += value
          }
          break
        default:
          const valuetype = vx_core.f_type_from_any(value)
          switch (valuetype) {
          case vx_core.t_int:
          case vx_core.t_float:
            value = value['vx_value']
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output += value
            }
            break
          case vx_core.t_string:
            value = parseFloat(value['vx_value'])
            if (isfirst) {
              isfirst = false
              output = value
            } else {
              output += value
            }
            break
          case vx_core.t_msgblock:
            msgblock = value
            break
          case vx_core.t_msg:
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
            break
          default:
            const typename = vx_core.f_typename_from_typedef(typedef)
            const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
            break
          }
        }
      })
      if (msgblock != vx_core.e_msgblock) {
        output = {
          vx_type: typedef,
          vx_value: output,
          vx_msgblock: msgblock
        }
      }
      break
    case vx_core.t_string:
      output = ''
      if (type == vx_core.t_string) {
      } else if ((typeof copy) == 'string') {
        output = copy
      } else {
        output = copy['vx_value']
        const testmsgblock = copy['vx_msgblock']
        if (testmsgblock != undefined) {
          msgblock = testmsgblock
        }
      }
      values.map(value => {
        switch (typeof value) {
        case 'boolean':
          if (value) {
            output += 'true'
          } else {
            output += 'false'
          }
          break
        case 'number':
        case 'string':
          output += '' + value
          break
        default:
          const valuetype = vx_core.f_typedef_from_any(value)
          switch (valuetype) {
          case vx_core.t_int:
          case vx_core.t_float:
            output += '' + value
            break
          case vx_core.t_string:
            output += value
            break
          case vx_core.t_msgblock:
            msgblock = value
            break
          case vx_core.t_msg:
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
            break
          default:
            const typename = vx_core.f_typename_from_typedef(typedef)
            const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
            break
          }
          break
        }
      })
      if (msgblock != vx_core.e_msgblock) {
        output = {
          vx_type: typedef,
          vx_value: output,
          vx_msgblock: msgblock
        }
      }
      break
    default:
      let allowany = false
      let allowtypes = []
      let key = ''
      let propmap = {}
      const extend = vx_core.f_extends_from_typedef(typedef)
      switch (extend) {
      case ':func':
        // output = vx_core.f_mempool-getvalue()
        let fn = null
        const empty = vx_core.f_empty(typedef)
        if (type == typedef) {
        } else {
          fn = copy['vx_value']
          const testmsgblock = copy['vx_msgblock']
          if (testmsgblock != undefined) {
            msgblock = testmsgblock
          }
        }
        values.map(value => {
          if (value == empty) {
          } else if ((typeof value) == 'function') {
            fn = value
          } else {
            const valuetype = vx_core.f_type_from_any(value)
            if (value == valuetype) {
              fn = valuetype['vx_value']['fn']
            } else {
              switch (valuetype) {
              case vx_core.t_msgblock:
                msgblock = value
                break
              case vx_core.t_msg:
                msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
                break
              default:
                const typename = vx_core.f_typename_from_typedef(typedef)
                const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
                msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
                break
              }
            }
          }
        })
        if ((fn != null) || (msgblock != vx_core.e_msgblock)) {
          output = {}
          output['vx_type'] = typedef
          if (fn != null) {
            output['vx_value'] = fn
          }
          if (msgblock != vx_core.e_msgblock) {
            output['vx_msgblock'] = msgblock
          }
        } else {
          output = empty
        }
        break
      case ':list':
        // output = vx_core.f_mempool-getvalue()
        const listvals = []
        if (type == typedef) {
        } else {
          listvals = copy.slice()
          const testmsgblock = copy['vx_msgblock']
          if (testmsgblock != undefined) {
            msgblock = testmsgblock
          }
        }
        allowtypes = vx_core.f_allowtypes_from_typedef(typedef)
        if (allowtypes.includes(vx_core.t_any)) {
          allowany = true
        }
        values.map(value => {
          const valuetype = vx_core.f_type_from_any(value)
          let isfound = false
          if (typedef == valuetype) {
            listvals.push(...value)
            isfound = true
          } else if (allowany) {
            listvals.push(value)
            isfound = true
          } else if (allowtypes.includes(valuetype)) {
            listvals.push(value)
            isfound = true
          } else {
            switch (valuetype) {
            case vx_core.t_msgblock:
              msgblock = value
              isfound = true
              break
            case vx_core.t_msg:
              msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
              isfound = true
              break
            default:
              const valuetraits = vx_core.f_traits_from_typedef(valuetype)
              const intersection = allowtypes.filter(function(n) {
                return valuetraits.indexOf(n) > -1
              })
              if (intersection.length > 0) {
                listvals.push(value)
                isfound = true
              }
              break
            }
          }
          if (!isfound) {
            const typename = vx_core.f_typename_from_typedef(typedef)
            const msg = vx_core.f_msg_from_error('(new ' + typename + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Value')
            msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
          }
        })
        if ((listvals.length > 0) || (msgblock != vx_core.e_msgblock)) {
          output = listvals
          output['vx_type'] = typedef
          if (msgblock != vx_core.e_msgblock) {
            output['vx_msgblock'] = msgblock
          }
        } else {
          output = vx_core.f_empty(typedef)
        }
        break
      case ':map':
        if (type != typedef) {
          propmap = Object.assign({}, copy['vx_value'])
          const testmsgblock = copy['vx_msgblock']
          if (testmsgblock != undefined) {
            msgblock = testmsgblock
          }
        }
        allowtypes = vx_core.f_allowtypes_from_typedef(typedef)
        if (allowtypes.includes(vx_core.t_any)) {
          allowany = true
        }
        values.map(value => {
          const valuetype = vx_core.f_type_from_any(value)
          if (key == '') {
            switch (valuetype) {
            case vx_core.t_string:
              if ((typeof value) == 'string') {
                key = value
              } else {
                key = value['vx_value']
              }
              if (key.startsWith(':')) {
                key = key.substring(1)
              }
              break
            case vx_core.t_msgblock:
              msgblock = value
              break
            case vx_core.t_msg:
              msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
              break
            default:
              const typename = vx_core.f_typename_from_typedef(typedef)
              const msg = vx_core.f_msg_from_error('(new ' + typename + ' :key ' + vx_core.f_string_from_any(value) + ') - Invalid Key')
              msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
              break
            }
          } else {
            if (allowany) {
              propmap[key] = value
            } else if (allowtypes.includes(valuetype)) {
              propmap[key] = value
            } else {
              const valuetraits = vx_core.f_traits_from_typedef(valuetype)
              const intersection = allowtypes.filter(function(n) {
                return valuetraits.indexOf(n) > -1
              })
              if (intersection.length > 0) {
                propmap[key] = value
              } else {
                const typename = vx_core.f_typename_from_typedef(typedef)
                const msg = vx_core.f_msg_from_error('(new ' + typename + ' :key ' + key + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Key Value')
                msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
              }
            }
            key = ''
          }
        })
        // output = vx_core.f_mempool-getvalue()
        if ((Object.keys(propmap).length > 0) || (msgblock != vx_core.e_msgblock)) {
          output = {
            vx_type: typedef,
            vx_value: propmap
          }
          if (msgblock != vx_core.e_msgblock) {
            output['vx_msgblock'] = msgblock
          }
        } else {
          output = vx_core.f_empty(typedef)
        }
        break
      case ':struct':
        switch (typedef) {
        case vx_core.t_msgblock:
        case type:
          break
        default:
          propmap = Object.assign({}, copy['vx_value'])
          const testmsgblock = copy['vx_msgblock']
          if (testmsgblock != undefined) {
            msgblock = testmsgblock
          }
          break
        }
        if (values.length > 0) {
          const properties = vx_core.f_properties_from_typedef(typedef)
          const lastprop = vx_core.f_proplast_from_typedef(typedef)
          const validkeys = Object.keys(properties)
          let lastpropname = ''
          let lasttype = null
          let lastallowtypes = []
          const ismulti = lastprop['multi']
          if (ismulti) {
            lastpropname = lastprop['name']
            lasttype = lastprop['type']
            lastallowtypes = vx_core.f_allowtypes_from_typedef(lasttype)
          }
          let testkey = ''
          values.map(value => {
            const valuetype = vx_core.f_type_from_any(value)
            if (key == '') {
              switch (valuetype) {
              case vx_core.t_string:
                if ((typeof value) == 'string') {
                  testkey = value
                } else {
                  testkey = value['vx_value']
                }
                if (testkey.startsWith(':')) {
                  testkey = testkey.substring(1)
                }
                if (validkeys.includes(testkey)) {
                  key = testkey
                } else {
                  const typename = vx_core.f_typename_from_typedef(typedef)
                  const msg = vx_core.f_msg_from_error('(new ' + typename + ' :key ' + vx_core.f_string_from_any(value) + ') - Invalid Key')
                  msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
                }
                break
              case vx_core.t_msgblock:
                switch (typedef) {
                case vx_core.t_msg:
                  // invalid msg cannot contain msgblock
                  break
                case vx_core.t_msgblock:
                  if (value == vx_core.t_msgblock) {
                  } else {
                    let msgblocks = propmap['msgblocks']
                    if (msgblocks == undefined) {
                      msgblocks = [value]
                      msgblock['vx_type'] = vx_core.t_msgblocklist
                    } else {
                      msgblocks.push(value)
                    }
                    propmap['msgblocks'] = msgblocks
                  }
                  break
                default:
                  msgblock = vx_core.f_msgblock_from_msgblock_msgblock(msgblock, value)
                  break
                }
                break
              case vx_core.t_msg:
                switch (typedef) {
                case vx_core.t_msg:
                  // invalid msg cannot contain msg
                  break
                case vx_core.t_msgblock:
                  let msgs = propmap['msgs']
                  if (msgs == undefined) {
                    msgs = [value]
                    msgs['vx_type'] = vx_core.t_msglist
                  } else {
                    msgs.push(value)
                  }
                  propmap['msgs'] = msgs
                  break
                default:
                  msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, value)
                  break
                }
                break
              default:
                let isfound = false
                if (!ismulti) {
                } else if (lasttype == vx_core.t_any) {
                  isfound = true
                } else if (lasttype == valuetype) {
                  isfound = true
                } else if (lastallowtypes.length > 0) {
                  if (lastallowtypes.includes(valuetype)) {
                    isfound = true
                  } else {
                    const valuetraits = vx_core.f_traits_from_typedef(valuetype)
                    const intersection = lastallowtypes.filter(function(n) {
                      return valuetraits.indexOf(n) > -1
                    })
                    if (intersection.length > 0) {
                      isfound = true
                    }
                  }
                }
                if (isfound) {
                  let lastpropvalue = propmap[lastpropname]
                  if (lastpropvalue == undefined) {
                    lastpropvalue = []
                    lastpropvalue['vx_type'] = lasttype
                    propmap[lastpropname] = lastpropvalue
                  }
                  if (lasttype == valuetype) {
                    lastpropvalue.push(...value)
                  } else {
                    lastpropvalue.push(value)
                  }
                } else {
                  const typename = vx_core.f_typename_from_typedef(typedef)
                  const msg = vx_core.f_msg_from_error('(new ' + typename + ' :key ' + vx_core.f_string_from_any(value) + ') - Invalid Key')
                  msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
                }
                break
              }
            } else {
              const property = properties[key]
              const propertytype = property['type']
              if (propertytype == vx_core.t_any) {
                propmap[key] = value
              } else if (propertytype == valuetype) {
                propmap[key] = value
              } else {
                const typename = vx_core.f_typename_from_typedef(typedef)
                const msg = vx_core.f_msg_from_error('(new ' + typename + ' :key ' + key + ' :value ' + vx_core.f_string_from_any(value) + ') - Invalid Key Value')
                msgblock = vx_core.f_msgblock_from_msgblock_msg(msgblock, msg)
              }
              key = ''
            }
          })
        }
        // output = vx_core.f_mempool-getvalue()
        if ((Object.keys(propmap).length > 0) || (msgblock != vx_core.e_msgblock)) {
          output = {
            vx_type: typedef,
            vx_value: propmap
          }
          if (msgblock != vx_core.e_msgblock) {
            output['vx_msgblock'] = msgblock
          }
        } else {
          output = vx_core.f_empty(typedef)
        }
        break
      }
      break
    }"
  :java
   "Core.Type_any[] arrayany = Core.arrayany_from_anylist(values);
    Object[] arrayobj = (Core.Type_any[])arrayany;
    T output = (T)(type.vx_new(arrayobj));")
 :doc "Create a new Value of Type A"
 :test (test true (new boolean true))
       (test 4 (new int 4))
       (test 5.4 (new float 5.4))
       (test "a" (new string "a"))
       (test
        (stringlist "a" "b" "c")
        (new stringlist "a" "b" "c"))
       (test
        (stringmap :a "1" :b "2")
        (new stringmap :a "1" :b "2")))

(func number<-func : number
 []
 :doc "Function Type returning number with any parameters")

(func or : boolean
 [val1 : boolean
  val2 : boolean]
 (native
  :cpp
   "if (val1->vx_boolean() || val2->vx_boolean()) {
      output = vx_core::c_true();
    } else {
      output = vx_core::c_false();
    }"
  :js
   "if (val1 || val2) {
      output = true
    } else {
      output = false
    }"
  :java
   "if (val1.vx_boolean() || val2.vx_boolean()) {
      output = Core.c_true;
    } else {
      output = Core.c_false;
    }")
 :doc  "Returns true if any value is true"
 :test (test-true (or true true))
       (test-true (or true false))
       (test-false (or false false)))

(func or : boolean
 [values : booleanlist :...]
 (any<-list-reduce-next : boolean
  values
  false
  (fn : boolean
   [reduce  : boolean
    current : boolean
    next    : boolean]
   (or reduce (or current next)))
 )
 :doc  "Returns true if any value is true"
 :test (test-true (or false true false))
       (test-false (or false false false)))

(func packagename<-typedef : string
 [vtypedef : typedef]
 (:pkgname vtypedef)
 :doc "Returns the package name from a typedef.")

(func path<-context-path : string
 [path : string]
 (path<-setting-path
  (setting<-context)
  path)
 :context
 :doc "Returns a path from a context")

(func path<-setting-path : string
 [session : setting
  path    : string]
 :doc "Returns a path from a setting")

(func permission<-id-context : permission
 [id : string]
 (let
  [user          : user          := (user<-context)
   security      : security      := (:security user)
   permissionmap : permissionmap := (:permissionmap security)]
  (:id permissionmap))
 :context
 :doc "Return a permission from context by id")

(func properties<-typedef : argmap
 [vtypedef : typedef]
 (:properties vtypedef)
 :doc "Return property map from typedef")

(func proplast<-typedef : arg
 [vtypedef : typedef]
 (:proplast vtypedef)
 :doc "Return last property from typedef")

(func resolve : any-1
 [value : any-1]
 value
 :test (test "a" (resolve "a")))

(func resolve : any-1
 [fn-any : any<-func]
 (native
  :cpp
   "if (fn_any) {
      vx_core::Type_any any = fn_any->vx_any_from_func();
      output = vx_core::vx_any_from_any(generic_any_1, any);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = fn()
      }
      break
    default:
      output = fn_any
      break
    }"
  :java
   "if (fn_any != null) {
      output = fn_any.f_any_from_func(generic_any_1);
    }")
 :test (test 4 (resolve (fn : int [] (+ 1 3)))))

(func resolve-async : any-1 :async
 [fn-any : any<-func-async]
 (native
  :cpp
   "if (fn_any) {
      output = fn_any->vx_any_from_func_async(generic_any_1);
    }"
  :js
   "const typedef = " (typedef<-any fn-any) "
    const extend = vx_core.f_extends_from_typedef(typedef)
    switch (extend) {
    case ':func':
      const fn = fn_any['vx_value']
      if (fn) {
        output = await fn()
      }
      break
    default:
      output = fn_any
      break
    }"
  :java
   "if (fn_any != null) {
      output = fn_any.f_any_from_func_async(generic_any_1);
    }")
 :test (test 4 (resolve : int (fn : int [] (+ 1 3)))))

(func resolve-first : any-1
 [clauses : list-1 :...]
 (first<-list-fn-any<-any clauses resolve)
 :doc "Returns the first value that is not nothing")

(func resolve-list : list-1
 [clauses : list-1]
 (list<-list clauses resolve))

(func session<-context : session
 (:session context)
 :context
 :doc "Returns session from a context")

(func setting<-context : setting
 (:setting context)
 :context
 :doc "Returns setting from a context")

(func string-repeat : string
 [text   : string
  repeat : int]
 (native
  :cpp
   "std::string stringtext = vx_core::vx_string_from_string_repeat(text->vx_string(), repeat->vx_int());
    output = vx_core::vx_new_string(stringtext);"
  :js "text.repeat(repeat)"
  :java
   "String stringtext = text.vx_string();
    int intrepeat = repeat.vx_int();
    String stringresult = stringtext.repeat(intrepeat);
    output = Core.t_string.vx_new_from_string(stringresult);")
 :test (test "abab" (string-repeat "ab" 2)))

(func string<-any : string
 [value : any]
 (string<-any-indent value 0 true)
 :test (test "true"  (string<-any true))
       (test "4"     (string<-any 4))
       (test "5.4"   (string<-any 5.4))
       (test "\"a\"" (string<-any "a"))
       (test
        "(stringlist
          \"a\"
          \"b\"
          \"c\")"
        (string<-any (stringlist "a" "b" "c")))
       (test
        "(stringmap
          :a \"1\"
          :b \"2\")"
        (string<-any (stringmap :a "1" :b "2")))
 :doc "Return a string representation of a value")

(func string<-any-indent : string
 [value    : any
  indent   : int
  linefeed : boolean]
 (native
  :cpp
   "std::string soutput = vx_core::vx_string_from_any_indent(value, indent->vx_int(), linefeed->vx_boolean());
    output = vx_core::vx_new_string(soutput);"
  :js
   "const indenttext = ' '.repeat(indent)
    let text = ''
    const typedef = vx_core.f_typedef_from_any(value)
    if (indent > 50) {
      text = 'Error: Max Depth Exceeded'
    } else if (value == null) {
      text = 'null'
    } else if (value == typedef) {
      text = vx_core.f_typename_from_typedef(typedef)
    } else {
      switch (typedef) {
      case vx_core.t_boolean:
        if (value == true) {
          text = 'true'
        } else {
          text = 'false'
        }
        break
      case vx_core.t_decimal:
        text = '' + value
        break
      case vx_core.t_float:
        text = '' + value
        if (text.endsWith('.0')) {
          text = text.substring(0, text.length() - 2)
        }
        break
      case vx_core.t_int:
        if (value == vx_core.c_notanumber) {
          text = 'notanumber'
        } else if (value == vx_core.c_infinity) {
          text = 'infinity'
        } else if (value == vx_core.c_neginfinity) {
          text = 'neginfinity'
        } else {
          text = '' + value
        }
        break
      case vx_core.t_string:
        text = '\"' + value + '\"'
        break
      default:
        const typedefname = typedef['vx_value']['name']
        const extend = vx_core.f_extends_from_typedef(typedef)
        switch (extend) {
        case ':list':
          indent += 1
          for (const valsub of value) {
            const valtext = vx_core.f_string_from_any_indent(valsub, indent, linefeed)
            text += '\n ' + indenttext + valtext
          }
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + typedefname + text + ')'
          break
        case ':map':
        case ':struct':
          indent += 2
          const valmap = value['vx_value']
          for (let key in valmap) {
            const valsub = valmap[key]
            if (!key.startsWith(':')) {
              key = ':' + key
            }
            let valtext = vx_core.f_string_from_any_indent(valsub, indent, linefeed)
            if (valtext.indexOf('\n') >= 0) {
              valtext = '\n  ' + indenttext + valtext
            } else {
              valtext = ' ' + valtext
            }
            text += '\n' + indenttext + ' ' + key + valtext
          }
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + typedefname + text + ')'
          break
        case ':func':
          text = typedefname
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + text + ')'
          break
        }
        break
      }
    }
    output = text"
  :java
   "String indenttext = “ ”.repeat(indent.vx_int());
    String text = “”;
    if (indent.vx_int() > 50) {
      text = “Error: Max Depth Exceeded”;
    } else if (value == null) {
      text = “null”;
    } else if (value == value.vx_type()) {
      Core.Type_typedef typedef = value.vx_typedef();
      text = typedef.pkgname().vx_string() + “/” + typedef.name().vx_string();
    } else if (value instanceof Core.Type_boolean) {
      Core.Type_boolean valbool = Core.f_any_from_any(Core.t_boolean, value);
      if (valbool.vx_boolean() == true) {
        text = “true”;
      } else {
        text = “false”;
      }
    } else if (value instanceof Core.Type_decimal) {
      Core.Type_decimal valdec = Core.f_any_from_any(Core.t_decimal, value);
      text = valdec.vx_string();
    } else if (value instanceof Core.Type_float) {
      Core.Type_float valfloat = Core.f_any_from_any(Core.t_float, value);
      text = Float.toString(valfloat.vx_float());
      if (text.endsWith(“.0”)) {
        text = text.substring(0, text.length() - 2);
      }
    } else if (value instanceof Core.Type_int) {
      if (value == Core.c_notanumber) {
        text = “notanumber”;
      } else if (value == Core.c_infinity) {
        text = “infinity”;
      } else if (value == Core.c_neginfinity) {
        text = “neginfinity”;
      } else {
        Core.Type_int valint = Core.f_any_from_any(Core.t_int, value);
        text = Integer.toString(valint.vx_int());
      }
    } else if (value instanceof Core.Type_string) {
      Core.Type_string valstring = Core.f_any_from_any(Core.t_string, value);
      text = “\"” + valstring.vx_string() + “\"”;
    } else if (value instanceof Core.Type_list) {
      Core.Type_list vallist = Core.f_any_from_any(Core.t_list, value);
      Core.Type_typedef typedef = vallist.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      int indentint = indent.vx_int();
      indentint += 1;
      List<Core.Type_any> listval = vallist.vx_list();
      for (Core.Type_any valsub : listval) {
        Core.Type_string valtext = Core.f_string_from_any_indent(valsub, Core.t_int.vx_new_from_int(indentint), linefeed);
        text += “\n ” + indenttext + valtext.vx_string();
      }
      if (vallist.vx_msgblock() != null) {
        Core.Type_string msgtext = Core.f_string_from_any_indent(vallist.vx_msgblock(), Core.t_int.vx_new_from_int(indentint), linefeed);
        text += “\n” + indenttext + “ :msgblock\n  ” + indenttext + msgtext.vx_string();
      }
      text = “(” + typedefname.vx_string() + text + “)”;
    } else if (value instanceof Core.Type_map) {
      Core.Type_map valmap = Core.f_any_from_any(Core.t_map, value);
      Core.Type_typedef typedef = valmap.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      int indentint = indent.vx_int();
      indentint += 2;
      Map<String, Core.Type_any> mapval = valmap.vx_map();
      Set<String> keys = mapval.keySet();
      for (String key : keys) {
        Core.Type_any valsub = mapval.get(key);
        if (!key.startsWith(“:”)) {
          key = “:” + key;
        }
        Core.Type_string valtext = Core.f_string_from_any_indent(valsub, Core.t_int.vx_new_from_int(indentint), linefeed);
        String strval = valtext.vx_string();
        if (strval.contains(“\n”)) {
          strval = “\n  ” + indenttext + strval;
        } else {
          strval = “ ” + strval;
        }
        text += “\n” + indenttext + “ ” + key + strval;
      }
      if (valmap.vx_msgblock() != null) {
        Core.Type_string msgtext = Core.f_string_from_any_indent(valmap.vx_msgblock(), Core.t_int.vx_new_from_int(indentint), linefeed);
        text += “\n” + indenttext + “ :msgblock\n  ” + indenttext + msgtext.vx_string();
      }
      text = “(” + typedefname.vx_string() + text + “)”;
    } else if (value instanceof Core.Type_struct) {
      Core.Type_struct valstruct = Core.f_any_from_any(Core.t_struct, value);
      Core.Type_typedef typedef = valstruct.vx_typedef();
      Core.Type_string typedefname = typedef.name();
      Core.Type_map valmap = Core.t_map.vx_new_from_map(valstruct.vx_map());
      String valtext = Core.f_string_from_any_indent(valmap, indent, linefeed).vx_string();
      text = valtext.replaceFirst(“map”, typedefname.vx_string());
    } else if (value instanceof Core.Type_func) {
      Core.Type_func valfunc = Core.f_any_from_any(Core.t_func, value);
      Core.Type_funcdef funcdef = valfunc.vx_funcdef();
      Core.Type_string funcdefname = Core.f_funcname_from_funcdef(funcdef);
      text = funcdefname.vx_string();
      if (valfunc.vx_msgblock() != null) {
        Core.Type_string msgtext = Core.f_string_from_any_indent(valfunc.vx_msgblock(), indent, linefeed);
        text += “\n” + indenttext + “ :msgblock\n  ” + indenttext + msgtext.vx_string();
      }
      text = “(” + text + “)”;
    }
    output = Core.t_string.vx_new_from_string(text);")
 :doc "Return a string representation of a value")

(func string<-func : string
 []
 :doc "Function Type returning string with any parameters")

(func switch : any-1
 [val          : any-2
  thenelselist : thenelselist :...]
 (native
  :js
   "let fn_any = null
    if (thenelselist.length > 0) {
      for (let valthenelse of thenelselist) {
        const thenelse = valthenelse['vx_value']
        const code = thenelse['code']
        switch (code) {
        case ':case':
          const value = thenelse['value']
          if (value == val) {
            fn_any = thenelse['fn-any']
          } else if (typeof value == 'number') {
            // special handling of notanumber
            if (isNaN(val) && isNaN(value)) {
              fn_any = thenelse['fn-any']
            }
          }
          break
        case ':casemany':
          const values = thenelse['values']
          if (values.includes(val)) {
            fn_any = thenelse['fn-any']
          }
          break
        case ':else':
          fn_any = thenelse['fn-any']
          break
        }
        if (fn_any != null) {
          break
        }
      }
      if (fn_any != null) {
        const fn = fn_any['vx_value']
        if (fn) {
          output = fn()
        }
      }
    }"
  :java
   "Core.Func_any_from_func fn_any = null;
    List<Core.Type_thenelse> listthenelse = thenelselist.vx_listthenelse();
    for (Core.Type_thenelse thenelse : listthenelse) {
      Core.Type_string code = thenelse.code();
      switch (code.vx_string()) {
      case “:case”:
        Core.Type_any value = thenelse.value();
        Core.Type_boolean iseq = Core.f_eq(val, value);
        if (iseq.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:casemany”:
        Core.Type_list values = thenelse.values();
        Core.Type_boolean iscontain = Core.f_contains_1(values, val);
        if (iscontain.vx_boolean()) {
          fn_any = thenelse.fn_any();
        }
        break;
      case “:else”:
        fn_any = thenelse.fn_any();
        break;
      }
      if (fn_any != null) {
        break;
      }
    }
    if (fn_any != null) {
      output = fn_any.f_any_from_func(generic_any_1);
    }")
 :test (test 1
        (switch : int
         "d"
         (case (list "b" "c" "d") 1)
         (else 2))))

(func then : thenelse
 [fn-cond : boolean<-func
  fn-any  : any<-func]
 (thenelse
  :code    :then
  :fn-cond fn-cond
  :fn-any  fn-any))

(func traits<-typedef : typelist
 [vtypedef : typedef]
 (native
  :cpp
   "vtypedef->traits();"
  :js
   "vtypedef['vx_value']['traits']"
  :java
   "vtypedef.traits();")
 :doc "Return trait list from type")

(func type<-any : any
 [value : any-1]
 (native
  :cpp
   "value->vx_type();"
  :js
   "switch (typeof value) {
    case 'boolean':
      output = " boolean "
      break
    case 'number':
      switch (value) {
      case " infinity ":
      case " neginfinity ":
      case " notanumber ":
        output = " int "
        break
      default:
        const strval = '' + value
        if (strval.indexOf('.') < 0) {
          output = " int "
        } else {
          output = " float "
        }
        break
      }
      break
    case 'string':
      output = " string "
      break
    case 'function':
      output = " func "
      break
    default:
      output = value['vx_type']
      if (output == vx_core.t_type) {
        output = value
      }
      break
    }"
  :java
   "output = value.vx_type();")
 :test (test boolean (type<-any false))
       (test int (type<-any 5))
       (test string (type<-any "a"))
 :doc  "Gets the Type of a given Value")

(func typedef<-any : typedef
 [val : any]
 (typedef<-type (type<-any val)))

(func typedef<-type : typedef
 [val : any]
 (native
  :cpp
   "val->vx_typedef();"
  :js
   "output = val"
  :java
   "val.vx_typedef();"))

(func typename<-any : string
 [value : any-2]
 (typename<-type (type<-any value))
 :test (test "vx/core/boolean" (typename<-any false))
       (test "vx/core/int"     (typename<-any 5))
       (test "vx/core/string"  (typename<-any "a"))
 :doc  "Gets the type of a given value")

(func typename<-type : string
 [type : any]
 (typename<-typedef (typedef<-type type))
 :doc "Get the name of a given type")

(func typename<-typedef : string
 [vtypedef : typedef]
 (string (:pkgname vtypedef) "/" (:name vtypedef))
 :doc "Get the name of a given type")

(func typenames<-typelist : stringlist
 [typelist : typelist]
 (list<-list : stringlist
  typelist
  (fn : string
   [type : any]
   (typename<-type type)))
 :doc "Get the names from a type list")

(func user<-context : user
 (:user (session<-context))
 :context
 :doc "Returns the current user from context.")
