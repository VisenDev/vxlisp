  public interface Map<TKey, TValue> {
  }

  public class LinkedHashMap<TKey, TValue> : Map<TKey, TValue> {
  }

  public interface vx_Type_const {
    public vx_core.Type_constdef vx_constdef();
  }

  public interface Type_replfunc {
    public vx_core.Type_any vx_repl(vx_core.Type_anylist arglist);
  }

  public interface Type_replfunc_async {
    public Task<vx_core.Type_any> vx_repl(vx_core.Type_anylist arglist);
  }

  public static List<vx_core.Type_any> emptylistany = new List<vx_core.Type_any>();

  public static Map<String, vx_core.Type_any> emptymapany = new LinkedHashMap<String, vx_core.Type_any>();

  public class Class_base {
    protected int vx_iref = 0;
    protected vx_core.Type_constdef vxconstdef = null;
    protected vx_core.Type_msgblock vxmsgblock = null;
    public virtual vx_core.Type_any vx_new(params Object[] vals) {
      return e_any;
    }
    public virtual vx_core.Type_any vx_copy(params Object[] vals) {
      return e_any;
    }
    public virtual vx_core.Type_any vx_empty() {
      return e_any;
    }
    public virtual vx_core.Type_any vx_type() {
      return t_any;
    }
    public virtual vx_core.Type_typedef vx_typedef() {
      return e_typedef;
    }
    public List<Type_any> vx_dispose() {
      this.vx_iref = 0;
      this.vxmsgblock = null;
      return emptylistany;
    }
    public vx_core.Type_msgblock vx_msgblock() {return vxmsgblock;}
    public bool vx_release() {
      bool output = false;
      if (this.vx_iref < 0) {
      } else if (vx_iref == 0) {
        vx_iref = -1;
        output = true;
      } else {
        vx_iref -= 1;
      }
      return output;
    }
    public void vx_reserve() {this.vx_iref += 1;}
  }

  public class KeyValue<T> {
    public String key = "";
    public T value = null;
  }

  public static vx_core.Type_constdef constdef_new(
    String pkgname,
    String name,
    vx_core.Type_any typ
  ) {
    vx_core.Class_constdef output = new vx_core.Class_constdef();
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname);
    output.vx_p_name = vx_core.vx_new_string(name);
    output.vx_p_type = typ;
    return output;
  }

  public static vx_core.Type_funcdef funcdef_new(
    String pkgname,
    String name,
    int idx,
    bool async,
    vx_core.Type_any typ
  ) {
    vx_core.Class_funcdef output = new vx_core.Class_funcdef();
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname);
    output.vx_p_name = vx_core.vx_new_string(name);
    output.vx_p_idx = vx_core.vx_new_int(idx);
    output.vx_p_async = vx_core.vx_new_boolean(async);
    output.vx_p_type = typ;
    return output;
  }

  public static vx_core.Type_any[] arrayany_from_anylist(vx_core.Type_anylist list) {
    return list.vx_list().toArray(new vx_core.Type_any[0]);
  }

  public static List<T> arraylist_from_array<T>(params T[] items) {
    List<T> output = new List<>(items);
    return output;
  }

  public static List<T> arraylist_from_arraylist<T, U>(T generic_any_1, List<U> listval) where T : vx_core.Type_any where U : vx_core.Type_any {
    List<T> output = new List<>();
    foreach (vx_core.Type_any value in listval) {
      T t_val = vx_core.f_any_from_any(generic_any_1, value);
      output.add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_arraylist_fn<T, U>(List<U> listval, Func<U, T> fn_any_from_any) {
    List<T> output = new List<>();
    foreach (U value_u in listval) {
      T t_val = fn_any_from_any.apply(value_u);
      output.add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_linkedhashmap<T, U>(T generic_any_1, LinkedHashMap<String, U> mapval) where T : vx_core.Type_any where U : vx_core.Type_any {
    List<T> output = new List<T>();
    Set<String> keys = mapval.keySet();
    foreach (String key in keys) {
      U u_val = mapval.get(key);
      T t_val = vx_core.f_any_from_any(generic_any_1, u_val);
      output.add(t_val);
    }
    return output;
  }

  public static List<T> arraylist_from_linkedhashmap_fn<T, U>(Map<String, U> mapval, Func<String, U, T> fn_any_from_key_value) {
    List<T> output = new List<T>();
    Set<String> keys = mapval.keySet();
    foreach (String key in keys) {
      U u_val = mapval.get(key);
      T t_val = fn_any_from_key_value.apply(key, u_val);
      output.add(t_val);
    }
    return output;
  }

  public static Task<T> async_new_completed<T>(T val) {
    Task<T> output = Task.completedFuture(val);
    return output;
  }

  public static Task<T> async_from_async<T, U>(T generic_any_1, Task<U> future) where T : vx_core.Type_any where U : vx_core.Type_any {
    Task<T> output = future.thenApply(val => {
      return vx_core.f_any_from_any(generic_any_1, val);
    });
    return output;
  }

  public static Task<T> async_from_async_fn<T, U>(Task<U> future, Func<U, T> fn) {
    Task<T> output = future.ContinueWith(antecedent => {
      U result = antedcedent.Result;
      return fn(result);
    });
    return output;
  }

  public static Task<List<T>> async_arraylist_from_arraylist_async<T>(List<Task<T>> list_future) {
    Task<Void> allFutures = Task.allOf(
      list_future.toArray(new Task[list_future.size()])
    );
    Task<List<T>> output = allFutures.thenApply(v => {
      List<T> list = list_future.stream()
        .map(future => future.join())
        .collect(Collectors.toList());
      return list;
    });
    return output;
  }

  public static LinkedHashMap<String, T> hashmap_from_keyvalues<T>(params KeyValue<T>[] keyvalues) {
    LinkedHashMap<String, T> output = new LinkedHashMap<>();
    foreach (KeyValue<T> keyvalue in keyvalues) {
      String key = keyvalue.key;
      T value = keyvalue.value;
      output.put(key, value);
    }
    return output;
  }

  public static KeyValue<T> keyvalue_from_key_value<T>(String key, T value) {
    KeyValue<T> output = new KeyValue<T>();
    output.key = key;
    output.value = value;
    return output;
  }

  public static Map<String, T> map_from_list_fn<T>(List<T> listval, Func<T, vx_core.Type_string> fn_any_from_any) {
    Map<String, T> output = new LinkedHashMap<>();
    foreach (T val in listval) {
      vx_core.Type_string valkey = fn_any_from_any.apply(val);
      String key = valkey.vx_string();
      output.put(key, val);
    }
    return output;
  }

  public static LinkedHashMap<String, T> map_from_map<T>(LinkedHashMap<String, vx_core.Type_any> mapval) where T : vx_core.Type_any {
    LinkedHashMap<String, T> output = new LinkedHashMap<>();
    Set<String> keys = mapval.keySet();
    foreach (String key in keys) {
      vx_core.Type_any value = mapval.get(key);
      try {
        T castval = (T)value;
        output.put(key, castval);
      } catch (Exception ex) {
        vx_core.vx_log("map<-map", ex);
      }
    }
    return output;
  }

  // vx_boolean_from_string_ends(string, string)
  public static bool vx_boolean_from_string_ends(String text, String ends) {
    return text.endsWith(ends);
  }

  // vx_boolean_from_string_find(string, string)
  public static bool vx_boolean_from_string_find(String text, String find) {
    return text.contains(find);
  }

  // vx_boolean_from_string_starts(string, string)
  public static bool vx_boolean_from_string_starts(String text, String starts) {
    return text.startsWith(starts);
  }

  // vx_eqeq(any, any)
  public static bool vx_eqeq(vx_core.Type_any val1, vx_core.Type_any val2) {
    bool output = false;
    if (val1 == val2) {
      output = true;
    } else if (val1.vx_msgblock() != vx_core.e_msgblock) {
    } else if (val2.vx_msgblock() != vx_core.e_msgblock) {
    } else {
      vx_core.Type_any type1 = val1.vx_type();
      vx_core.Type_any type2 = val2.vx_type();
      if (type1 != type2) {
      } else if (type1 == vx_core.t_int) {
        vx_core.Type_int valint1 = (vx_core.Type_int)val1;
        vx_core.Type_int valint2 = (vx_core.Type_int)val2;
        if (valint1.vx_int() == valint2.vx_int()) {
          output = true;
        }
      } else if (type1 == vx_core.t_float) {
        vx_core.Type_float valfloat1 = (vx_core.Type_float)val1;
        vx_core.Type_float valfloat2 = (vx_core.Type_float)val2;
        if (valfloat1.vx_float() == valfloat2.vx_float()) {
          output = true;
        }
      } else if (type1 == vx_core.t_decimal) {
        vx_core.Type_decimal valdecimal1 = (vx_core.Type_decimal)val1;
        vx_core.Type_decimal valdecimal2 = (vx_core.Type_decimal)val2;
        if (valdecimal1.vx_string() == valdecimal2.vx_string()) {
          output = true;
        }
      } else if (type1 == vx_core.t_string) {
        vx_core.Type_string valstring1 = (vx_core.Type_string)val1;
        vx_core.Type_string valstring2 = (vx_core.Type_string)val2;
        if (valstring1.vx_string() == valstring2.vx_string()) {
          output = true;
        }
      }
    }
    return output;
  }

  // vx_float_from_string(string)
  public static float vx_float_from_string(String text) {
    float output = 0;
    try {
      output = Float.parseFloat(text);
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_global_package_set(string, map<any>, map<any>, map<func>)
  public static void vx_global_package_set(String pkgname, Map<String, vx_core.Type_any> maptype, Map<String, vx_core.Type_any> mapconst, Map<String, vx_core.Type_func> mapfunc) {
    vx_core.Class_typemap typemap = new vx_core.Class_typemap();
		  typemap.vx_p_map = maptype;
	   vx_core.Class_constmap constmap = new vx_core.Class_constmap();
		  constmap.vx_p_map = mapconst;
		  vx_core.Class_funcmap funcmap = new vx_core.Class_funcmap();
		  funcmap.vx_p_map = mapfunc;
    vx_core.Class_project global = (vx_core.Class_project)vx_core.c_global;
    vx_core.Class_packagemap packagemap = (vx_core.Class_packagemap)global.vx_p_packagemap;
    if (packagemap == null) {
      packagemap = new vx_core.Class_packagemap();
      global.vx_p_packagemap = packagemap;
    }
    Map<String, vx_core.Type_package> mappackage = new LinkedHashMap<>(packagemap.vx_p_map);
		  vx_core.Class_package pkg = new vx_core.Class_package();
		  pkg.vx_p_constmap = constmap;
		  pkg.vx_p_typemap = typemap;
		  pkg.vx_p_funcmap = funcmap;
    mappackage.put(pkgname, pkg);
    packagemap.vx_p_map = mappackage;
  }

  // vx_int_from_string(string)
  public static int vx_int_from_string(String text) {
    int output = 0;
    try {
      output = Integer.parseInt(text);
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_int_from_string_find(string, string)
  public static int vx_int_from_string_find(String text, String find) {
    return text.IndexOf(find);
  }

  // vx_int_from_string_findlast(string, string)
  public static int vx_int_from_string_findlast(String text, String findlast) {
    return text.LastIndexOf(findlast);
  }

  // vx_is_float(string)
  public static bool vx_is_float(String text) {
    bool output = false;
    try {
      Float.parseFloat(text);
      output = true;
    } catch (Exception e) {
    }    
    return output;
  }

  // vx_is_float(any)
  public static bool vx_is_float(vx_core.Type_any value) {
    bool output = false;
    if (value is vx_core.Type_number) {
      output = true;
    } else if (value is vx_core.Type_string) {
      vx_core.Type_string valuestring = (vx_core.Type_string)value;
      output = vx_core.vx_is_float(valuestring.vx_string());
    }
    return output;
  }

  // vx_is_int(string)
  public static bool vx_is_int(String text) {
    bool output = false;
    switch (text) {
    case "notanumber":
    case "infinity":
    case "neginfinity":
      output = true;
      break;
    default:
      try {
        Integer.parseInt(text);
        output = true;
      } catch (Exception e) {
      }
      break;
    }
    return output;
  }

  // vx_is_int(any)
  public static bool vx_is_int(vx_core.Type_any value) {
    bool result = false;
    if (value == vx_core.c_infinity) {
      result = true;
    } else if (value == vx_core.c_neginfinity) {
      result = true;
    } else if (value == vx_core.c_notanumber) {
      result = true;
    } else if (value is vx_core.Type_int) {
      result = true;
    } else if (value is vx_core.Type_float) {
      vx_core.Type_float valfloat = (vx_core.Type_float)value;
      float floatval = valfloat.vx_float();
      if ((int)floatval == floatval) {
        result = true;
      }
    } else if (value is vx_core.Type_decimal) {
      vx_core.Type_decimal valdec = (vx_core.Type_decimal)value;
      String strval = valdec.vx_string();
      try {
        if (Integer.parseInt(strval) == Float.parseFloat(strval)) {
          result = true;
        }
      } catch (Exception ex) {
      }
    } else if (value is vx_core.Type_string) {
      vx_core.Type_string valstr = (vx_core.Type_string)value;
      String strval = valstr.vx_string();
      result = vx_is_int(strval);
    }
    return result;
  }

  // vx_log(object...)
  public static void vx_log(params Object[] values) {
    foreach (Object value in values) {
      String text = "";
      if (value == null) {
        text = "null";
      } else if (value is vx_core.Type_string) {
        vx_core.Type_string valstring = (vx_core.Type_string)value;
        text = valstring.vx_string();
      } else if (value is vx_core.Type_any) {
        vx_core.Type_any valany = (vx_core.Type_any)value;
        vx_core.Type_string valstring = vx_core.f_string_from_any(valany);
        text = valstring.vx_string();
      } else {
        text = value.toString();
      }
      System.Console.WriteLine(text);
    }
  }

  // vx_msg_error
  public static Type_msg vx_msg_error(String text) {
    Class_msg output = new Class_msg();
    output.vx_p_text = vx_core.vx_new_string(text);
    output.vx_p_severity = vx_core.c_msg_severe;
    return output;
  }

  // vx_msg_from_exception
  public static Type_msg vx_msg_from_exception(String text, Exception err) {
    Class_msg output = new Class_msg();
    output.vx_p_text = vx_core.vx_new_string(text);
    output.vx_p_severity = vx_core.c_msg_severe;
    output.err = err;
    vx_core.vx_log(output);
    return output;
  }

  public static Type_boolean vx_new_boolean(bool isval) {
    Type_boolean output = vx_core.c_false;
    if (isval) {
      output = vx_core.c_true;
    }
    return output;
  }

  public static Type_float vx_new_float(float fval) {
    Class_float output = new vx_core.Class_float();
    output.vxfloat = fval;
    return output;
  }

  public static Type_int vx_new_int(int ival) {
    Type_int output;
    if ((ival == 0) && vx_core.e_int != null) {
      output = vx_core.e_int;
    } else {
      Class_int work = new vx_core.Class_int();
      work.vxint = ival;
      output = work;

    }
    return output;
  }

  public static Type_string vx_new_string(String text) {
    Type_string output;
    if (text.equals("") && vx_core.e_string != null) {
      output = vx_core.e_string;
    } else {
      Class_string work = new vx_core.Class_string();
      work.vxstring = text;
      output = work;
    }
    return output;
  }

  public static String vx_string_from_any(vx_core.Type_any value) {
    return vx_string_from_any_indent(value, 0, false);
  }

  public static String vx_string_from_any_indent(vx_core.Type_any value, int indent, bool linefeed) {
    String indenttext = " ".repeat(indent);
    String output = "";
    if (indent > 50) {
      output = "Error: Max Depth Exceeded";
    } else if (value == null) {
      output = "null";
    } else if (value == value.vx_type()) {
      if (value is vx_core.Type_func) {
        vx_core.Type_func valuefunc = (vx_core.Type_func)value;
        vx_core.Type_funcdef funcdef = valuefunc.vx_funcdef();
        output = funcdef.pkgname().vx_string() + "/" + funcdef.name().vx_string();
      } else {
        vx_core.Type_typedef typedef = value.vx_typedef();
        output = typedef.pkgname().vx_string() + "/" + typedef.name().vx_string();
      }
    } else if (value is vx_core.Type_boolean) {
      vx_core.Type_boolean valbool = vx_core.f_any_from_any(vx_core.t_boolean, value);
      if (valbool.vx_boolean() == true) {
        output = "true";
      } else {
        output = "false";
      }
    } else if (value is vx_core.Type_decimal) {
      vx_core.Type_decimal valdec = vx_core.f_any_from_any(vx_core.t_decimal, value);
      output = valdec.vx_string();
    } else if (value is vx_core.Type_float) {
      vx_core.Type_float valfloat = vx_core.f_any_from_any(vx_core.t_float, value);
      output = Float.toString(valfloat.vx_float());
      if (output.endsWith(".0")) {
        output = output.substring(0, output.length() - 2);
      }
    } else if (value is vx_core.Type_int) {
      if (value == vx_core.c_notanumber) {
        output = "notanumber";
      } else if (value == vx_core.c_infinity) {
        output = "infinity";
      } else if (value == vx_core.c_neginfinity) {
        output = "neginfinity";
      } else {
        vx_core.Type_int valint = vx_core.f_any_from_any(vx_core.t_int, value);
        output = Integer.toString(valint.vx_int());
      }
    } else if (value is vx_core.Type_string) {
      vx_core.Type_string valstring = vx_core.f_any_from_any(vx_core.t_string, value);
      output = "\"" + valstring.vx_string() + "\"";
    } else if (value is vx_core.vx_Type_const) {
      vx_core.vx_Type_const constvalue = (vx_core.vx_Type_const)value;
      vx_core.Type_constdef constdef = constvalue.vx_constdef();
      String constpkg = constdef.pkgname().vx_string();
      String constname = constdef.name().vx_string();
      if (constpkg.equals("vx/core")) {
        output = constname;
      } else {
        output = constpkg + "/" + constname;
      }
    } else if (value is vx_core.Type_list) {
      vx_core.Type_list vallist = vx_core.f_any_from_any(vx_core.t_list, value);
      vx_core.Type_typedef typedef = vallist.vx_typedef();
      vx_core.Type_string typedefname = typedef.name();
      int indentint = indent;
      indentint += 1;
      List<vx_core.Type_any> listval = vallist.vx_list();
      foreach (vx_core.Type_any valsub in listval) {
        String valtext = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed);
        output += "\n " + indenttext + valtext;
      }
      if (vallist.vx_msgblock() != null) {
        String msgtext = vx_core.vx_string_from_any_indent(vallist.vx_msgblock(), indentint, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is vx_core.Type_map) {
      vx_core.Type_map valmap = vx_core.f_any_from_any(vx_core.t_map, value);
      vx_core.Type_typedef typedef = valmap.vx_typedef();
      vx_core.Type_string typedefname = typedef.name();
      int indentint = indent;
      indentint += 2;
      Map<String, vx_core.Type_any> mapval = valmap.vx_map();
      Set<String> keys = mapval.keySet();
      foreach (String key in keys) {
        vx_core.Type_any valsub = mapval.get(key);
        if (!key.startsWith(":")) {
          key = ":" + key;
        }
        String strval = vx_core.vx_string_from_any_indent(valsub, indentint, linefeed);
        if (strval.contains("\n")) {
          strval = "\n  " + indenttext + strval;
        } else {
          strval = " " + strval;
        }
        output += "\n" + indenttext + " " + key + strval;
      }
      if (valmap.vx_msgblock() != null) {
        String msgtext = vx_core.vx_string_from_any_indent(valmap.vx_msgblock(), indentint, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is vx_core.Type_struct) {
      vx_core.Type_struct valstruct = vx_core.f_any_from_any(vx_core.t_struct, value);
      vx_core.Type_typedef typedef = valstruct.vx_typedef();
      vx_core.Type_string typedefname = typedef.name();
      int indentint2 = indent;
      indentint2 += 2;
      Map<String, vx_core.Type_any> mapval2 = valstruct.vx_map();
      Set<String> keys2 = mapval2.keySet();
      foreach (String key in keys2) {
        vx_core.Type_any valsub2 = mapval2.get(key);
        if (!vx_core.f_is_empty_1(valsub2).vx_boolean()) {
          if (!key.startsWith(":")) {
            key = ":" + key;
          }
          String strval2 = vx_core.vx_string_from_any_indent(valsub2, indentint2, linefeed);
          if (strval2.contains("\n")) {
            strval2 = "\n  " + indenttext + strval2;
          } else {
            strval2 = " " + strval2;
          }
          output += "\n" + indenttext + " " + key + strval2;
        }
      }
      if (valstruct.vx_msgblock() != null) {
        String msgtext2 = vx_core.vx_string_from_any_indent(valstruct.vx_msgblock(), indentint2, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext2;
      }
      output = "(" + typedefname.vx_string() + output + ")";
    } else if (value is vx_core.Type_func) {
      vx_core.Type_func valfunc = vx_core.f_any_from_any(vx_core.t_func, value);
      vx_core.Type_funcdef funcdef = valfunc.vx_funcdef();
      vx_core.Type_string funcdefname = vx_core.f_funcname_from_funcdef(funcdef);
      output = funcdefname.vx_string();
      if (valfunc.vx_msgblock() != null) {
        String msgtext = vx_core.vx_string_from_any_indent(valfunc.vx_msgblock(), indent, linefeed);
        output += "\n" + indenttext + " :msgblock\n  " + indenttext + msgtext;
      }
      output = "(" + output + ")";
    }
    return output;
  }

  public static String vx_string_from_string_start_end(String text, int start, int end) {
    String output = "";
    int maxlen = text.length();
    if (end < 0) {
     end += maxlen;
    }
    if (start < 1) {
    } else if (start > end) {
    } else if (start > maxlen) {
    } else {
      if (end >= maxlen) {
        end = maxlen;
      }
      output = text.substring(start - 1, end);
    }
    return output;
  }

  public static vx_core.Type_typedef typedef_new(
    String pkgname,
    String name,
    String extend,
    vx_core.Type_typelist traits,
    vx_core.Type_typelist allowtypes,
    vx_core.Type_typelist disallowtypes,
    vx_core.Type_funclist allowfuncs,
    vx_core.Type_funclist disallowfuncs,
    vx_core.Type_anylist allowvalues,
    vx_core.Type_anylist disallowvalues,
    vx_core.Type_argmap properties
  ) {
    vx_core.Class_typedef output = new vx_core.Class_typedef();
    output.vx_p_pkgname = vx_core.vx_new_string(pkgname);
    output.vx_p_name = vx_core.vx_new_string(name);
    output.vx_p_extend = vx_core.vx_new_string(extend);
    output.vx_p_traits = traits;
    output.vx_p_allowtypes = allowtypes;
    output.vx_p_disallowtypes = disallowtypes;
    output.vx_p_allowfuncs = disallowfuncs;
    output.vx_p_disallowfuncs = disallowfuncs;
    output.vx_p_allowvalues = disallowvalues;
    output.vx_p_disallowvalues = disallowvalues;
    output.vx_p_properties = properties;
    return output;
  }

  public static vx_core.Type_anylist vx_anylist_from_arraystring(String[] arraystring) {
    List<Object> listany = new List<>();
    foreach (String svalue in arraystring) {
      vx_core.Type_string value = vx_core.vx_new_string(svalue);
      listany.add(value);
    }
    Object[] arrayany = listany.toArray();
    vx_core.Type_anylist output = vx_core.t_anylist.vx_new(arrayany);
    return output;
  }

  // Warning!: Blocking
  public static T vx_sync_from_async<T>(T generic_any_1, Task<T> future) where T : vx_core.Type_any {
    T output = vx_core.f_empty(generic_any_1);
    try {
      output = future.get();
    } catch (Exception e) {
      vx_core.Type_msg msg = vx_core.vx_msg_from_exception("sync<-async", e);
      vx_core.Type_any val = generic_any_1.vx_new(msg);
      output = vx_core.f_any_from_any(generic_any_1, val);
    }
    return output;
  }
