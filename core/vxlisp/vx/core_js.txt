  static vx_string_from_any(value) {
    const output = vx_core.vx_string_from_any_indent(value, 0, false)
		return output
  }

  static vx_string_from_any_indent(value, indent, linefeed) {
    let output = ''
    const indenttext = ' '.repeat(indent)
		let text = ''
    const typedef = vx_core.f_typedef_from_any(value)
    if (indent > 50) {
      text = 'Error: Max Depth Exceeded'
    } else if (value == null) {
      text = 'null'
    } else if (value == typedef) {
      text = vx_core.f_typename_from_typedef(typedef)
    } else {
      switch (typedef) {
      case vx_core.t_boolean:
        if (value == true) {
          text = 'true'
        } else {
          text = 'false'
        }
        break
      case vx_core.t_decimal:
        text = '' + value
        break
      case vx_core.t_float:
        text = '' + value
        if (text.endsWith('.0')) {
          text = text.substring(0, text.length() - 2)
        }
        break
      case vx_core.t_int:
        if (value == vx_core.c_notanumber) {
          text = 'notanumber'
        } else if (value == vx_core.c_infinity) {
          text = 'infinity'
        } else if (value == vx_core.c_neginfinity) {
          text = 'neginfinity'
        } else {
          text = '' + value
        }
        break
      case vx_core.t_string:
        text = '\"' + value + '\"'
        break
      default:
        const typedefname = typedef['vx_value']['name']
        const extend = vx_core.f_extends_from_typedef(typedef)
        switch (extend) {
        case ':list':
          indent += 1
          for (const valsub of value) {
            const valtext = vx_core.f_string_from_any_indent(valsub, indent, linefeed)
            text += '\n ' + indenttext + valtext
          }
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + typedefname + text + ')'
          break
        case ':map':
        case ':struct':
          indent += 2
          const valmap = value['vx_value']
          for (let key in valmap) {
            const valsub = valmap[key]
            if (!key.startsWith(':')) {
              key = ':' + key
            }
            let valtext = vx_core.f_string_from_any_indent(valsub, indent, linefeed)
            if (valtext.indexOf('\n') >= 0) {
              valtext = '\n  ' + indenttext + valtext
            } else {
              valtext = ' ' + valtext
            }
            text += '\n' + indenttext + ' ' + key + valtext
          }
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + typedefname + text + ')'
          break
        case ':func':
          text = typedefname
          if (value['vx_msgblock'] != null) {
            const msgtext = vx_core.f_string_from_any_indent(value['vx_msgblock'], indent, linefeed)
            text += '\n' + indenttext + ' :msgblock\n  ' + indenttext + msgtext
          }
          text = '(' + text + ')'
          break
        }
        break
      }
    }
    output = text
		return output
  }
